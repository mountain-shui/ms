## 进程和线程 

  ### 二者的区别与几种状态 

![](images\2019-3Java运行时数据区域JDK1.8.png)

  区别：一个进程拥有多个线程，这些线程拥有共享的方法区和堆，但是每个线程都有自己独立的虚拟机栈、程序计数器、本地方法栈。

​			进程之间是相互独立的，线程之间可能是相互影响的，一个进程在执行过程中，可以产生多个线程。线程的执行开销小，不利于资源的维护。而进程的与之相反。

几种状态：创建：表示进程刚被创建不拥有任何的资源。

​					就绪：准备运行，表示已经获取了除了处理器之外的所有的资源，一旦得到处理机资源就可以开始运行。

​					执行：进程正在处理机上运行。

​					阻塞：表示等待IO、或者等待某资源可用，在这期间，就算是处理机空闲，也不能运行。

​					结束：表示进程正常运行结束，或者其他因素中断退出运行。

## 4.说一下Java的内存模型

java内存模型可分为一下几部分：虚拟机栈，本地方法栈，程序计数器，堆，方法区（1.8改为元空间）。

其中虚拟机栈，本地方法栈，程序计数器是线程私有的，堆，方法区是线程共享的。

1.6中方法区是在JVM内存中，1.8之后就放到了直接内存中。

虚拟机栈是存放运行Java方法时的内存模型，虚拟机栈中存放的是一个个的栈帧，每个栈帧包含5部分：局部变量表，操作数栈，指向常量池的引用，方法返回的地址，附加信息。

当运行一个方法的时候，就会将这个方法压入栈中，当运行结束就会出栈。

本地方法栈中是调用native修饰的方法时所使用的栈，也是在运行时会将方法压入栈，运行结束就出栈。

程序计数器是记录当前线程执行到或者将要执行哪个语句的记录器。用来在线程切换时，保存上下文信息。

堆是存储new出来的对象实例的地方，是垃圾回收的主要区域。

方法区是存放类对象的地方，当一个新的类想加载到JVM中，会先加载类对象到方法区，然后在根据类对象在堆中创建具体实例。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等

## 5.说一下栈桢

虚拟机栈中存放的是一个个的栈帧，每个栈帧包含5部分：局部变量表，操作数栈，指向常量池的引用，方法返回的地址。

局部变量表存放的是方法运行时的局部变量，操作数栈也相当于一个栈，是运行具体操作的地方。

指向常量池的引用，顾名思义，方法可能用到类中的常量，通过引用就可以直接找到数据。

方法返回的地址，在方法执行结束之后，会返回调用它的地方，这里存的是调用它的地址。

  ##  JVM 

  ### 1.内存分区

![JVM运行时数据区域](images\JVM运行时数据区域.png)

 ![2019-3Java运行时数据区域JDK1.8](images\2019-3Java运行时数据区域JDK1.8.png)



### 2.新建对象在哪个区 

![v2-c10ad0502710dff8af454625749b0637_720w](images\v2-c10ad0502710dff8af454625749b0637_720w.jpg)

 ### 3.垃圾回收机制介绍流程,fullGC,新生代、中生代 

1.创建对象的时候，对象需要有内存空间，也是需要为这个对象进行内存空间的申请

2首先判断伊甸园区（Eden）是否有内存空间，如果有就将对象保存到伊甸园区

3 如果空间不足，则自动执行Minor GC(从年轻代回收内存),将Eden区不活跃的对象清理，清理之后继续判断内存是否充足，若充足则分配内存
4 如果执行过后，Eden区仍然内存不足，那就进行存活区判断，如果存活区有内存空间，则将Eden区的部分活跃对象保存到存活区，随后继续判断Eden区内存空间是否充足，如果进行内存分配

5 如果存活期没有内存空间了，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区

6 当old区空间不够时，这个时候会产生Major GC(Full GC)

7  完全垃圾收集后，若Survivor及old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现"Out of memory错误"；

 ## 讲一下类加载机制流程 

![image-20210402104311026](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20210402104311026.png)

### 类的生命周期

一个类的完整生命周期如下：

[![img](https://camo.githubusercontent.com/b3cf0235f53756d8ac62c395ff3882b2cb11745e65cdb6178e7c3a0d50b18aff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d2545352541452538432545352539362538342e706e67)](https://camo.githubusercontent.com/b3cf0235f53756d8ac62c395ff3882b2cb11745e65cdb6178e7c3a0d50b18aff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d2545352541452538432545352539362538342e706e67)

### 类加载过程

Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？

系统加载 Class 类型的文件主要三步:**加载->连接->初始化**。连接过程又可分为三步:**验证->准备->解析**。

[![img](https://camo.githubusercontent.com/7078336ec98b1f79e04e9fc60f514915f723c042c99e20cccb5d8bc18d45a3c6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422e706e67)](https://camo.githubusercontent.com/7078336ec98b1f79e04e9fc60f514915f723c042c99e20cccb5d8bc18d45a3c6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422e706e67)

### 

### 加载

类加载过程的第一步，主要完成下面3件事情：

1. **通过全类名获取定义此类的二进制字节流**
2. **将字节流所代表的静态存储结构转换为方法区的运行时数据结构**
3. **在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口**



**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

### 

### 验证

[![验证阶段示意图](https://camo.githubusercontent.com/2d2bf0d21ff1cd9b2a9634077b8ddd2e8e3615d8154e8129bb727cc6617f4a80/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67)](https://camo.githubusercontent.com/2d2bf0d21ff1cd9b2a9634077b8ddd2e8e3615d8154e8129bb727cc6617f4a80/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67)

文件格式验证：验证字节流是否符合 **Class 文件格式**的规范，并且能被当前版本的虚拟机处理。
元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 **Java 语言规范**的要求。
字节码验证：通过数据流和控制流分析，确保**程序语义**是合法、符合逻辑的。
符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，**对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验**。

### 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

1. 这时候进行内存分配的仅包括**类变量**（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（**初始化阶段才会赋值**）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

**基本数据类型的零值：**

[![基本数据类型的零值](https://camo.githubusercontent.com/40c7cc86b5ccbbc0fd37a501c5be5111790a5bb575f56dbbb94e5943b904b73a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352539462542412545362539432541432545362539352542302545362538442541452545372542312542422545352539452538422545372539412538342545392539422542362545352538302542432e706e67)](https://camo.githubusercontent.com/40c7cc86b5ccbbc0fd37a501c5be5111790a5bb575f56dbbb94e5943b904b73a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352539462542412545362539432541432545362539352542302545362538442541452545372542312542422545352539452538422545372539412538342545392539422542362545352538302542432e706e67)

### 解析

解析阶段是虚拟机**将常量池内的符号引用替换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

符号引用就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java  虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 

### 初始化

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 `<clinit> ()`方法的过程。

**根据程序员通过程序制定的主观计划去初始化类变量和其它资源。**

对于`<clinit>（）` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit>（）` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。

对于初始化阶段，虚拟机严格规范了有且只有**5种情况下，必须对类进行初始化**(**只有主动去使用类才会初始化类**)：

1. 当**遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令**时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
   - 当jvm执行new指令时会初始化类。即当程序**创建一个类的实例对象**。
   - 当jvm执行getstatic指令时会初始化类。即程序**访问类的静态变量**(不是静态常量，常量会被加载到运行时常量池)。
   - 当jvm执行putstatic指令时会初始化类。即程序**给类的静态变量赋值**。
   - 当jvm执行invokestatic指令时会初始化类。即**程序调用类的静态方法**。
2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用时如Class.forname("..."),newInstance()等等。 ，如果类没初始化，需要触发其初始化。**
3. **初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。**
4. 当虚拟机启动时，用户需要定义一个要执行的**主类** (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。
6. **「补充，来自[issue745](https://github.com/Snailclimb/JavaGuide/issues/745)」** 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 卸载

> 卸载这部分内容来自 [issue#662](https://github.com/Snailclimb/JavaGuide/issues/662)由 **[guang19](https://github.com/guang19)**  补充完善。

卸载类即该类的Class对象被GC。

卸载类需要满足3个要求:

1. **该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。**
2. **该类没有在其他任何地方被引用**
3. **该类的类加载器的实例已被GC**

所以，在JVM生命周期类，由**jvm自带的类加载器加载的类是不会被卸载**的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。





## 5.final修饰类 方法 属性区别。 

final修饰类：表示该类不可以被继承

final修饰方法：表示该方法不可以被重写。

final修饰属性：表示该属性一经初始化就不可以被修改，对于基本变量来说是其值不能修改，对于引用变量来说是其引用不可以再修改。

## 6.JVM内存布局，虚拟机栈本地方法栈，栈帧里的结构，哪些区域线程私有公有。 

![img](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

![img](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

本地方法栈的栈帧：局部变量表、操作数栈、动态链接、出口信息。

公有区域：堆，方法区（元空间）。

私有区域：虚拟机栈、本地方法栈、程序计数器。

## 7.堆区域的划分，垃圾回收算法，标记算法，内存分配算法（和垃圾回收器相关）。

在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

[![JVM堆内存结构-JDK7](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png)](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM堆内存结构-JDK7.png)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

[![JVM堆内存结构-JDK8](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png)](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM堆内存结构-jdk8.png)

**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**

![垃圾收集算法分类](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png)

![垃圾收集器分类](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

标记算法有：引用计数法、可达性分析法。

引用计数法是为每一个对象分配一个计数器，每当有其他对象引用它，计数器加一。当计数器为0时，表示当前对象没有任何引用，可以被GC了。这个方法简单高效，但是没办法解决循环引用问题。

可达性分析法：将一系列GC root当作根节点，向下根据引用关系寻找可达对象，寻找过程叫做引用链，一个系统可以有多个根节点。如果一个对象无法通过任何的GC root搜索到，则被认为没有任何引用，可以被GC。可达性分析算法必须处于一致性快照中，也就是STW（Stop the word）,因为如果同时有对象的引用被更改，可达性分析算法就不准确了。

**内存分配算法**

Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有指针碰撞和空闲列表两种实现方式。

**1.指针碰撞法**
假设Java堆中内存时完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。使用的GC收集器：Serial、ParNew，适用堆内存规整（即没有内存碎片）的情况下。

**2.空闲列表法**
事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。使用的GC收集器：CMS，适用堆内存不规整的情况下。

## 8.还问了[项目]()中使用了什么垃圾回收器，serial serial old。

## 9.方法区，元空间。 具体怎么优化解决STW问题。 

元空间与永久代最大的区别在于：元空间不在虚拟机内存中，而是使用本地内存。

**永久代为什么要被元空间替换**
随着java8的到来，hotspot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。
由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
这项改动是很有必要的，原因有：

* 为永久代设置空间大小是很难确定的。

* 在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM。比如某个时间的Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误：
  java.lang.OutOfMemoryError:PermGen space
  而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制

* 对永久代进行调优是很困难的。
  full GC 严重影响性能。

* 放在本地内存不会影响Jvm在运行时的性能，因为都是放在本地内存中，而不是放在本地磁盘上。

  **怎么优化解决STW问题**

  首先看一下日志 是因为啥发生的吧 如果minor gc过多 就调整新生代大小 full gc过多就调整老年代大小

## 10.对象的所有过程，创建销毁，加载链接初始化，分配内存CAS（还讲了TLAB参数），具体怎么移动到老年代（15），还讲了具体操作数栈中的过程，内存泄漏。 

对象的从new关键字开始被创建，在new的过程中，首先在常量池中查找是否可以定位到一个符号引用的类，查看这个类是否经过了加载连接初始化，如果不存在类对象，则开始执行类加载过程。

类加载过程:加载 > 连接 > 初始化。其中连接又分为三部分：验证 > 准备 > 解析。

加载的过程就是将class文件从各个来源通过类加载器加载到内存中。

验证：对文件格式的验证：验证文件格式是否符合规范

​			验证元数据，对字节流进行语义分析，判断是否符合java语言规范。

​			字节码验证：确认程序的语义是合法的，合乎逻辑的

​			符号引用验证：确认可以根据符号引用找到相对应的匹配。

准备：在堆内存中的Eden区为类变量分配内存，并赋予java默认的初始值。这里的内存分配算法有指针碰撞法，空闲列表法，碰撞指针法：假设java内存是规整的，指针在已使用内存和未使用内存的分界处，每当需要分配内存时，就将指针移动所需要的大小，使用的GC器有serial，pernew等内存规整的情况。空闲列表法：记录每一块空闲的内存，当需要内存分配就在列表中拿出一块进行分配，使用的GC器有CMS，适合内存不规整的情况。

内存分配中带来的线程不安全问题，在并发环境下即使修改的只是一个指针，也会引起线程不安全问题。有两种解决方法，一种是对操作进行同步处理，实际上虚拟机使用CAS+失败重试方式保证线程安全。二是在堆中为每个线程提前分配一个TLAB（本地线程分配缓存），哪个内存需要进行缓存时，就在自己线程的TLAB上进行分配，只有在分配TLAB时才需要同步锁定，虚拟机中使用-XX：+/-UseTLAB命令开启。

解析：将符号引用转化成直接引用。

初始化：在这个阶段，会根据程序员的主观的设计，对变量进行初始化赋值。

对象在使用过程中，第一次从Eden区经过新生代垃圾回收机制还有没被回收，则进入Survivor区中的s0或者s1区（大对象直接进入老年代），如果又经过一次GC，没有被回收则年龄+1，当年龄到达一定大小（默认为15），就晋升到老年代。

操作数栈是一个在做运算的时候临时的内存区域，将局部变量表中的元素，加载到操作数栈中，进行运算，结束后写回到局部变量表。

## 11.CMS 和 G1相关也讲了一下。 

CMS：concurrent mark sweep，注重用户体验的垃圾回收器。

主要分成四个阶段：初始标记 > 并发标记 > 重新标记 > 并发清理

初始标记：首次对垃圾进行标记，是很短暂的，记录下直接与GC ROOT 相连的对象。

并发标记：应用程序线程和GC线程同时运行，用一个闭包结构记录可达对象。

重新标记：因为上一阶段是并发执行的，这一阶段就是对上一阶段中有引用修改的进行修正。这一阶段比并发标记长。

并发清理：这一阶段是应用程序和GC线程同时运行，将标记的垃圾进行清理。

优点是：并发执行，低停顿。

缺点：对CPU资源敏感，无法处理浮动垃圾，使用标记-清除算法，会产生大量垃圾碎片。

G1：Garbage first，面向服务器的垃圾回收器。G1将整个堆分成了大小相同的内存块，每个块可以是Eden，也可以是Survivor，也可以是old。在回收前后会自动变化。

具有一下优势：

并发并行：充分利用多核多线程的优势，来缩短STW时间，

分代收集：G1不需要与其他的垃圾回收器配合就可以自己管理整个堆，但还是保留了分代的概念。

空间整合：从整体来看是标记整理，从部分来看是标记-复制。

可预测的停顿：可以指定什么时候进行STW。

分为以下几个步骤:初始标记 > 并发标记 > 最终标记 > 筛选回收。

G1在后台维护了一个优先列表，每次根据允许的收集时间，选择最有回收价值的区域进行回收。 