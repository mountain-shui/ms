## 进程和线程 

  ### 二者的区别与几种状态 

![](images\2019-3Java运行时数据区域JDK1.8.png)

  区别：一个进程拥有多个线程，这些线程拥有共享的方法区和堆，但是每个线程都有自己独立的虚拟机栈、程序计数器、本地方法栈。

​			进程之间是相互独立的，线程之间可能是相互影响的，一个进程在执行过程中，可以产生多个线程。线程的执行开销小，不利于资源的维护。而进程的与之相反。

几种状态：创建：表示进程刚被创建不拥有任何的资源。

​					就绪：准备运行，表示已经获取了除了处理器之外的所有的资源，一旦得到处理机资源就可以开始运行。

​					执行：进程正在处理机上运行。

​					阻塞：表示等待IO、或者等待某资源可用，在这期间，就算是处理机空闲，也不能运行。

​					结束：表示进程正常运行结束，或者其他因素中断退出运行。



  ##  JVM 

  ### 1.内存分区

![JVM运行时数据区域](images\JVM运行时数据区域.png)

 ![2019-3Java运行时数据区域JDK1.8](images\2019-3Java运行时数据区域JDK1.8.png)



### 2.新建对象在哪个区 

![v2-c10ad0502710dff8af454625749b0637_720w](images\v2-c10ad0502710dff8af454625749b0637_720w.jpg)

 ### 3.垃圾回收机制介绍流程,fullGC,新生代、中生代 

1.创建对象的时候，对象需要有内存空间，也是需要为这个对象进行内存空间的申请

2首先判断伊甸园区（Eden）是否有内存空间，如果有就将对象保存到伊甸园区

3 如果空间不足，则自动执行Minor GC(从年轻代回收内存),将Eden区不活跃的对象清理，清理之后继续判断内存是否充足，若充足则分配内存
4 如果执行过后，Eden区仍然内存不足，那就进行存活区判断，如果存活区有内存空间，则将Eden区的部分活跃对象保存到存活区，随后继续判断Eden区内存空间是否充足，如果进行内存分配

5 如果存活期没有内存空间了，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区

6 当old区空间不够时，这个时候会产生Major GC(Full GC)

7  完全垃圾收集后，若Survivor及old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现"Out of memory错误"；