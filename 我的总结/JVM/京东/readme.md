## 进程和线程 

  ### 二者的区别与几种状态 

![](images\2019-3Java运行时数据区域JDK1.8.png)

  区别：一个进程拥有多个线程，这些线程拥有共享的方法区和堆，但是每个线程都有自己独立的虚拟机栈、程序计数器、本地方法栈。

​			进程之间是相互独立的，线程之间可能是相互影响的，一个进程在执行过程中，可以产生多个线程。线程的执行开销小，不利于资源的维护。而进程的与之相反。

几种状态：创建：表示进程刚被创建不拥有任何的资源。

​					就绪：准备运行，表示已经获取了除了处理器之外的所有的资源，一旦得到处理机资源就可以开始运行。

​					执行：进程正在处理机上运行。

​					阻塞：表示等待IO、或者等待某资源可用，在这期间，就算是处理机空闲，也不能运行。

​					结束：表示进程正常运行结束，或者其他因素中断退出运行。



  ##  JVM 

  ### 1.内存分区

![JVM运行时数据区域](images\JVM运行时数据区域.png)

 ![2019-3Java运行时数据区域JDK1.8](images\2019-3Java运行时数据区域JDK1.8.png)



### 2.新建对象在哪个区 

![v2-c10ad0502710dff8af454625749b0637_720w](images\v2-c10ad0502710dff8af454625749b0637_720w.jpg)

 ### 3.垃圾回收机制介绍流程,fullGC,新生代、中生代 

1.创建对象的时候，对象需要有内存空间，也是需要为这个对象进行内存空间的申请

2首先判断伊甸园区（Eden）是否有内存空间，如果有就将对象保存到伊甸园区

3 如果空间不足，则自动执行Minor GC(从年轻代回收内存),将Eden区不活跃的对象清理，清理之后继续判断内存是否充足，若充足则分配内存
4 如果执行过后，Eden区仍然内存不足，那就进行存活区判断，如果存活区有内存空间，则将Eden区的部分活跃对象保存到存活区，随后继续判断Eden区内存空间是否充足，如果进行内存分配

5 如果存活期没有内存空间了，当OLD区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区

6 当old区空间不够时，这个时候会产生Major GC(Full GC)

7  完全垃圾收集后，若Survivor及old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现"Out of memory错误"；

 ## 讲一下类加载机制流程 

### 类的生命周期

一个类的完整生命周期如下：

[![img](https://camo.githubusercontent.com/b3cf0235f53756d8ac62c395ff3882b2cb11745e65cdb6178e7c3a0d50b18aff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d2545352541452538432545352539362538342e706e67)](https://camo.githubusercontent.com/b3cf0235f53756d8ac62c395ff3882b2cb11745e65cdb6178e7c3a0d50b18aff/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422d2545352541452538432545352539362538342e706e67)

### 类加载过程

Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？

系统加载 Class 类型的文件主要三步:**加载->连接->初始化**。连接过程又可分为三步:**验证->准备->解析**。

[![img](https://camo.githubusercontent.com/7078336ec98b1f79e04e9fc60f514915f723c042c99e20cccb5d8bc18d45a3c6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422e706e67)](https://camo.githubusercontent.com/7078336ec98b1f79e04e9fc60f514915f723c042c99e20cccb5d8bc18d45a3c6/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545372542312542422545352538412541302545382542442542442545382542462538372545372541382538422e706e67)

### 

### 加载

类加载过程的第一步，主要完成下面3件事情：

1. **通过全类名获取定义此类的二进制字节流**
2. **将字节流所代表的静态存储结构转换为方法区的运行时数据结构**
3. **在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口**



**一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 `loadClass()` 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。**

加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。

### 

### 验证

[![验证阶段示意图](https://camo.githubusercontent.com/2d2bf0d21ff1cd9b2a9634077b8ddd2e8e3615d8154e8129bb727cc6617f4a80/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67)](https://camo.githubusercontent.com/2d2bf0d21ff1cd9b2a9634077b8ddd2e8e3615d8154e8129bb727cc6617f4a80/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67)

文件格式验证：验证字节流是否符合 **Class 文件格式**的规范，并且能被当前版本的虚拟机处理。
元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 **Java 语言规范**的要求。
字节码验证：通过数据流和控制流分析，确保**程序语义**是合法、符合逻辑的。
符号引用验证：发生在虚拟机将符号引用转换为直接引用的时候，**对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验**。

### 准备

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：

1. 这时候进行内存分配的仅包括**类变量**（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了`public static int value=111` ，那么 value 变量在准备阶段的初始值就是 0 而不是111（**初始化阶段才会赋值**）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111` ，那么准备阶段 value 的值就被赋值为 111。

**基本数据类型的零值：**

[![基本数据类型的零值](https://camo.githubusercontent.com/40c7cc86b5ccbbc0fd37a501c5be5111790a5bb575f56dbbb94e5943b904b73a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352539462542412545362539432541432545362539352542302545362538442541452545372542312542422545352539452538422545372539412538342545392539422542362545352538302542432e706e67)](https://camo.githubusercontent.com/40c7cc86b5ccbbc0fd37a501c5be5111790a5bb575f56dbbb94e5943b904b73a/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545352539462542412545362539432541432545362539352542302545362538442541452545372542312542422545352539452538422545372539412538342545392539422542362545352538302542432e706e67)

### 解析

解析阶段是虚拟机**将常量池内的符号引用替换为直接引用**的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

符号引用就是一组符号来描述目标，可以是任何字面量。**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java  虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。

综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。

### 

### 初始化

初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行初始化方法 `<clinit> ()`方法的过程。

**根据程序员通过程序制定的主观计划去初始化类变量和其它资源。**

对于`<clinit>（）` 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 `<clinit>（）` 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。

对于初始化阶段，虚拟机严格规范了有且只有**5种情况下，必须对类进行初始化**(**只有主动去使用类才会初始化类**)：

1. 当**遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令**时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
   - 当jvm执行new指令时会初始化类。即当程序**创建一个类的实例对象**。
   - 当jvm执行getstatic指令时会初始化类。即程序**访问类的静态变量**(不是静态常量，常量会被加载到运行时常量池)。
   - 当jvm执行putstatic指令时会初始化类。即程序**给类的静态变量赋值**。
   - 当jvm执行invokestatic指令时会初始化类。即**程序调用类的静态方法**。
2. 使用 `java.lang.reflect` 包的方法对类进行**反射调用时如Class.forname("..."),newInstance()等等。 ，如果类没初始化，需要触发其初始化。**
3. **初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。**
4. 当虚拟机启动时，用户需要定义一个要执行的**主类** (包含 main 方法的那个类)，虚拟机会先初始化这个类。
5. MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。
6. **「补充，来自[issue745](https://github.com/Snailclimb/JavaGuide/issues/745)」** 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 卸载

> 卸载这部分内容来自 [issue#662](https://github.com/Snailclimb/JavaGuide/issues/662)由 **[guang19](https://github.com/guang19)**  补充完善。

卸载类即该类的Class对象被GC。

卸载类需要满足3个要求:

1. **该类的所有的实例对象都已被GC，也就是说堆不存在该类的实例对象。**
2. **该类没有在其他任何地方被引用**
3. **该类的类加载器的实例已被GC**

所以，在JVM生命周期类，由**jvm自带的类加载器加载的类是不会被卸载**的。但是由我们自定义的类加载器加载的类是可能被卸载的。

只要想通一点就好了，jdk自带的BootstrapClassLoader,ExtClassLoader,AppClassLoader负责加载jdk提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。

## 讲一下volatile关键字 

就我理解的而言，被volatile修饰的共享变量，就具有了以下两点特性：

- 1.保证了不同线程对该变量操作的内存可见性;
- 2.禁止指令重排序

### 什么是内存可见性，什么又是重排序呢？

由于CPU执行指令的速度是很快的，但是内存访问的速度就慢了很多，相差的不是一个数量级，所以搞处理器的那群大佬们又在CPU里加了好几层高速缓存。 

JMM规定所有变量都是存在主存中的，类似于上面提到的普通内存，每个线程又包含自己的工作内存，方便理解就可以看成CPU上的寄存器或者高速缓存。

所以线程的操作都是以工作内存为主，它们只能访问自己的工作内存，且工作前后都要把值在同步回主内存。 这么说得我自己都有些不清楚了，拿张纸画一下： 

![img](https://cdn.jiler.cn/techug/uploads/2018/01/1.png.jpg)

  在线程执行时，首先会从主存中read变量值，再load到工作内存中的副本中，然后再传给处理器执行，执行完毕后再给工作内存中的副本赋值，随后工作内存再把值传回给主存，主存中的值才更新。 使用工作内存和主存，虽然加快的速度，但是也带来了一些问题。比如看下面一个例子：



```java
i = i + 1;
```

假设i初值为0，当只有一个线程执行它时，结果肯定得到1，当两个线程执行时，会得到结果2吗？这倒不一定了。可能存在这种情况：

```java
线程1： load i from 主存    // i = 0
        i + 1  // i = 1
线程2： load i from主存  // 因为线程1还没将i的值写回主存，所以i还是0
        i +  1 //i = 1
线程1:  save i to 主存
线程2： save i to 主存
```

如果两个线程按照上面的执行流程，那么i最后的值居然是1了。

下面就要提到你刚才问到的问题了，JMM主要就是围绕着如何在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的，通过解决这三个问题，可以解除缓存不一致的问题。而volatile跟可见性和有序性都有关。

### 原子性、可见性和有序性

**1.原子性(Atomicity)：** Java中，对基本数据类型的读取和赋值操作是原子性操作，所谓原子性操作就是指这些操作是不可中断的，要做一定做完，要么就没有执行。 比如：

```java
i = 2;
j = i;
i++;
i = i + 1;
```

上面4个操作中，i=2是读取操作，必定是原子性操作，j=i你以为是原子性操作，其实吧，分为两步，一是读取i的值，然后再赋值给j,这就是2步操作了，称不上原子操作，i++和i = i +  1其实是等效的，读取i的值，加1，再写回主存，那就是3步操作了。所以上面的举例中，最后的值可能出现多种情况，就是因为满足不了原子性。  这么说来，只有简单的读取，赋值是原子操作，还只能是用数字赋值，用变量的话还多了一步读取变量值的操作。

JMM只实现了基本的原子性，像上面i++那样的操作，必须借助于synchronized和Lock来保证整块代码的原子性了。线程在释放锁之前，必然会把i的值刷回到主存的。 

**2. 可见性(Visibility)：** 说到可见性，Java就是利用volatile来提供可见性的。  当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要读取该变量时，会去内存中读取新值。而普通变量则不能保证这一点。

 **3. 有序性（Ordering）** JMM是允许编译器和处理器对指令重排序的，但是规定了as-if-serial语义，即不管怎么重排序，程序的执行结果不能改变。比如下面的程序段：

```java
double pi = 3.14;    //A
double r = 1;        //B
double s= pi * r * r;//C
```

上面的语句，可以按照A->B->C执行，结果为3.14,但是也可以按照B->A->C的顺序执行，因为A、B是两句独立的语句，而C则依赖于A、B，所以A、B可以重排序，但是C却不能排到A、B的前面。JMM保证了重排序不会影响到单线程的执行，但是在多线程中却容易出问题。 比如这样的代码:

```java
int a = 0;
bool flag = false;

public void write() {
    a = 2;              //1
    flag = true;        //2
}

public void multiply() {
    if (flag) {         //3
        int ret = a * a;//4
    }
}
```

假如有两个线程执行上述代码段，线程1先执行write，随后线程2再执行multiply，最后ret的值一定是4吗？结果不一定： 

![img](https://cdn.jiler.cn/techug/uploads/2018/01/2.png.jpg)

另外，JMM具备一些先天的有序性,即不需要通过任何手段就可以保证的有序性，通常称为happens-before原则。**happens-before规则**： 

* 单线程保证语义的串行性（书写在前面的操作先行发生于书写在后面的操作）
* volatile变量的写先于读发生
* 锁规则：解锁必然发生在加锁前（一个unlock操作先行发生于后面对同一个锁的lock操作）
* A先于B，B先于C，那么A必然先于C （先于，先行发生于）
* 线程的 start() 方法先于它的每一个动作
* 线程的所有操作先于线程的终结
* 线程的中断先于被中断线程的代码
* 构造函数的执行和结束 先于 finalize() 方法

### volatile关键字如何满足并发编程的三大特性的？

那就要重提volatile变量规则：就是如果一个变量声明成是volatile的，那么当我读变量时，总是能读到它的最新值，这里最新值是指不管其它哪个线程对该变量做了写操作，都会立刻被更新到主存里

```java
int a = 0;
bool flag = false;

public void write() {
   a = 2;              //1
   flag = true;        //2
}

public void multiply() {
   if (flag) {         //3
       int ret = a * a;//4
   }
}
```

这段代码不仅仅受到重排序的困扰，即使1、2没有重排序。3也不会那么顺利的执行的。假设还是线程1先执行write操作，线程2再执行multiply操作，由于线程1是在工作内存里把flag赋值为1，不一定立刻写回主存，所以线程2执行时，multiply再从主存读flag值，仍然可能为false，那么括号里的语句将不会执行。 如果改成下面这样：

```java
int a = 0;
volatile bool flag = false;

public void write() {
   a = 2;              //1
   flag = true;        //2
}

public void multiply() {
   if (flag) {         //3
       int ret = a * a;//4
   }
}
```

那么线程1先执行write,线程2再执行multiply。根据happens-before原则，这个过程会满足以下3类规则： **程序顺序规则：**1 happens-before 2; 3 happens-before 4; (volatile限制了指令重排序，所以1 在2 之前执行) 

### volatile的两点内存语义能保证可见性和有序性，但是能保证原子性吗？

首先我回答是不能保证原子性，要是说能保证，也只是对单个volatile变量的读/写具有原子性，但是对于类似volatile++这样的复合操作就无能为力了，比如下面的例子：

```java
public class Test {
    public volatile int inc = 0;
 
    public void increase() {
        inc++;
    }
 
    public static void main(String[] args) {
        final Test test = new Test();
        for(int i=0;i<10;i++){
            new Thread(){
                public void run() {
                    for(int j=0;j<1000;j++)
                        test.increase();
                };
            }.start();
        }
 
        while(Thread.activeCount()>1)  //保证前面的线程都执行完
            Thread.yield();
        System.out.println(test.inc);
    }
```

按道理来说结果是10000，但是运行下很可能是个小于10000的值。有人可能会说volatile不是保证了可见性啊，一个线程对inc的修改，另外一个线程应该立刻看到啊！可是这里的操作inc++是个复合操作啊，包括读取inc的值，对其自增，然后再写回主存。 假设线程A，读取了inc的值为10，这时候被阻塞了，因为没有对变量进行修改，触发不了volatile规则。  线程B此时也读读inc的值，主存里inc的值依旧为10，做自增，然后立刻就被写回主存了，为11。  此时又轮到线程A执行，由于工作内存里保存的是10，所以继续做自增，再写回主存，11又被写了一遍。所以虽然两个线程执行了两次increase()，结果却只加了一次。 有人说，**volatile不是会使缓存行无效的吗？**但是这里线程A读取到线程B也进行操作之前，并没有修改inc值，所以线程B读取的时候，还是读的10。 又有人说，线程B将11写回主存，**不会把线程A的缓存行设为无效吗？**但是线程A的读取操作已经做过了啊，只有在做读取操作时，发现自己缓存行无效，才会去读主存的值，所以这里线程A只能继续做自增了。  综上所述，在这种复合操作的情景下，原子性的功能是维持不了了。但是volatile在上面那种设置flag值的例子里，由于对flag的读/写操作都是单步的，所以还是能保证原子性的。 要想保证原子性，只能借助于synchronized,Lock以及并发包下的atomic的原子操作类了，即对基本数据类型的  自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。

### volatile底层的实现机制？

如果把加入volatile关键字的代码和未加入volatile关键字的代码都生成汇编代码，会发现加入volatile关键字的代码会多出一个lock前缀指令。 lock前缀指令实际相当于一个内存屏障，内存屏障提供了以下功能：

 **1.重排序时不能把后面的指令重排序到内存屏障之前的位置** 

**2.会将当前处理器缓存行的数据立即写会系统主存**

**3.这个写回内存的操作会引起在其他cpu里缓存了该内存地址的数据无效（MES协议）**

### 哪里会使用到volatile，举两个例子呢？

**1.状态量标记，就如上面对flag的标记，我重新提一下：**

```java
int a = 0;
volatile bool flag = false;

public void write() {
    a = 2;              //1
    flag = true;        //2
}

public void multiply() {
    if (flag) {         //3
        int ret = a * a;//4
    }
}
```

这种对变量的读写操作，标记为volatile可以保证修改对线程立刻可见。比synchronized,Lock有一定的效率提升。 **2.单例模式的实现，典型的双重检查锁定（DCL）**

```java
class Singleton{
    private volatile static Singleton instance = null;
 
    private Singleton() {
 
    }
 
    public static Singleton getInstance() {
        if(instance==null) {
            synchronized (Singleton.class) {
                if(instance==null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

这是一种懒汉的单例模式，使用时才创建对象，而且为了避免初始化操作的指令重排序，给instance加上了volatile。