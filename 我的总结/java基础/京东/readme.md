 ##  1.Java反射机制 

 ### 1.调用反射的几种方法 

```java
//1.源头：获取Class对象，用三种方式
		Phone iPhone=new Phone();
		//1.1.对象.getClass();获取对象
		Class<?> clazz1 = iPhone.getClass();
		//1.2.类.class
		 clazz1=Phone.class;
		//1.3.Class.forName("包名.类名");
		clazz1 = Class.forName("test.Phone");

//2.创建对象
		//2.1通过newInstence()
		Phone instance1 = (Phone) clazz1.newInstance();
		//2.2先调用构造器，再通过newInstence()创建
		Object instance2 = clazz1.getConstructor().newInstance();
```

 ### 2.与new的区别 

  new和反射本质上的区别，new属于静态编译，而反射属于动态编译，意思就说只有到运行时他才会去获得该对象的实例.

反射可以不用import就生成对象

一般会配合接口使用

如果不用反射，interface myobj=new classimpl（）

这样接口和实现类都要import进来

这样的话，如果实现类发生变动，需要重新编译，那这段代码也需要重新编译

如果用反射的话，实现类可以不用import进来

也能生成一个满足接口的对象出来

这样当实现类改动的时候，这段代码可以不用重新编译



##  抽象与接口，重写与重载 

  ### 1.默认构造函数能否重载重写 

首先，构造器是不能被继承的，因为每个类的类名都不相同，而构造器名称与类名相同，所以根本谈不上继承。
 又由于构造器不能继承，所以就不能被重写。但是，在同一个类中，构造器是可以被重载的。

## 面向对象的特性，怎么理解多态？ 

封装，继承，多态是面向对象的三大特性

多态：表示一个对象具有的多种状态，具体表现为父类引用指向子类实例。

有以下特点：

* 引用类型和对象类型之间存在实现/继承的关系。
* 引用类型具体调用哪个类中的方法，只有在程序运行期间才能确定。
* 不能调用父类中没有，子类中有的方法
* 如果子类实现了父类的方法，则调用子类的方法，如果没有实现，则调用父类的方法

继承：

子类可以继承父类，就是可以在父类的基础上，快速的创建类，提高代码的可用性，程序的可维护性。

* 子类拥有父类的所有属性和方法，但是不能使用父类的私有属性和方法
* 子类可以拥有自己的属性和方法，即子类可对父类进行拓展
* 子类可以按照自己的方式实现父类的方法

封装：可以不让外界访问方法中的变量，而是提供一种方法，外界可以通过这个方法，控制方法内的属性。

## 重写和重载的区别 

重写是指当子类继承自父类的相同方法，想要做出和父类不同的响应，就要覆盖父类的方法。

重载是指拥有相同方法名，可以根据输入参数的不同，做不同的处理。

## 快排的时间复杂度 

平均时间复杂度O(nlogn)

最坏情况时间复杂度O(n*n)

![1342700879_2982](G:\王鹏\面试\https\牛客面经\京东\images\1342700879_2982.jpg)

## 抽象类和接口的区别，接口里允许有私有方法吗？ 

* 抽象类中可以有构造方法，接口中不能有
* 抽象类中可以有protected方法，接口中不能有
* 抽象类中可以有具体方法实现，接口中不能有
* 抽象类中可以有静态方法，接口中不能有
* 一个类可以实现多个接口，但是只能继承一个抽象类

抽象类是为了代码的复用，接口是为了规定类必须有什么

java8中接口中不能有私有方法，java9中允许有私有方法和私有静态方法

## 2.直接开始java基础面 八大基本数据类型 

int(32位) float(32位) double(64位) boolean(1位) byte(8位) short(16位) long(64位) char(16位)

 ## 3.float a = 1.4f;float b = 1.1f a-b多少 (默认是double，类型最后输出是0.29999995) 



 ## 4.==和equals的关系，还有hashcode呢,hashcode和equals有什么关系 什么时候重写hashcode 

==：判断两个对象的地址是否相等，即判断两个对象是不是同一个对象。对于基本数据类型来说，判断的是值是否相同，对于引用数据类型，比较的是内存地址。

equlas：也是判断两个对象是否相等，但是不能用于比较基本数据类型。equals存在于Object类中，Objec类是所有类的父类。

equals有两种情况：1.类没有重写equals，通过equals比较该类时，等价于==；

2.类重写了equals，此时就是比较两个对象的内容是否一致。如果一致返回true

hashcode：是对象的物理地址通过散列转化而来，两个对象的hashcode相同，不一定equals，两个对象equals，则一定是有相同的hashcode。

**在每个类中，在重写 equals 方法的时侯，一定要重写 hashcode 方法。**如果不这样做，你的类违反了hashCode的通用约定，这会阻止它在HashMap和HashSet这样的集合中正常工作。

在java中，hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包含HashSet、HashMap、HashTable。

 ## 5.object类中有哪些方法（讲了getClass() ，hashCode() equals() toString() wait()（讲了wait和sleep的区别，通过notify() 唤醒） 

getclass：获取类的class对象

equals：比较对象是否相等，子类可以重写。

hashcode：获取hashcode值

toString：如果不重写，输出的是对象的地址。

wait：阻塞当前线程，只有唤醒它才能继续运行。

notify：随机唤醒一个wait该对象的线程，接触其阻塞状态。该方法只能在同步方法或者同步块内部调用。

notifyall：唤醒所有在该对象上调用wait的方法，接触阻塞状态。只能在同步方法快或者同步方法内部调用。

clone：克隆对象。

finalize：对象回收时调用。

 ## 异常 

  ### 1.异常的分类  

Exception:是程序本身的异常，可分成两类。

RuntimeException:主要由虚拟机抛出，是运行时异常。NullpointerException、ArithmeticException、ArrayIndexOutOfBoundsException。

IOException:IO异常。

  如何捕获异常 

  ### 2.OOM相关

1）什么是OOM？ OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。

2）为什么会OOM？

为什么会没有内存了呢？原因不外乎有两点：

1）分配的少了：比如虚拟机本身可使用的内存（一般通过启动时的VM参数指定）太少。

2）应用用的太多，并且用完没释放，浪费了。此时就会造成内存泄露或者内存溢出。

**内存泄露：申请使用完的内存没有释放**，导致虚拟机不能再次使用该内存，此时这段内存就泄露了，因为申请者不用了，而又不能被虚拟机分配给别人用。

**内存溢出：申请的内存超出了JVM能提供的内存大小**，此时称之为溢出。

3）OOM的类型

按照JVM规范，除了程序计数器不会抛出OOM外，其他各个内存区域都可能会抛出OOM。

最常见的OOM情况有以下三种：

    java.lang.OutOfMemoryError: Java heap space ------>java堆内存溢出，此种情况最常见，一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过虚拟机参数-Xms,-Xmx等修改。
    java.lang.OutOfMemoryError: PermGen space ------>java永久代溢出，即方法区溢出了，一般出现于大量Class或者jsp页面，或者采用cglib等反射机制的情况，因为上述情况会产生大量的Class信息存储于方法区。此种情况可以通过更改方法区的大小来解决，使用类似-XX:PermSize=64m -XX:MaxPermSize=256m的形式修改。另外，过多的常量尤其是字符串也会导致方法区溢出。
    java.lang.StackOverflowError ------> 不会抛OOM error，但也是比较常见的Java内存溢出。JAVA虚拟机栈溢出，一般是由于程序中存在死循环或者深度递归调用造成的，栈大小设置太小也会出现此种溢出。可以通过虚拟机参数-Xss来设置栈的大小。

4）OOM分析--heapdump

要dump堆的内存镜像，可以采用如下两种方式：

    设置JVM参数-XX:+HeapDumpOnOutOfMemoryError，设定当发生OOM时自动dump出堆信息。不过该方法需要JDK5以上版本。
    使用JDK自带的jmap命令。"jmap -dump:format=b,file=heap.bin <pid>"   其中pid可以通过jps获取。

dump堆内存信息后，需要对dump出的文件进行分析，从而找到OOM的原因。

 ## 讲一下string、stringbuffer、stringbuilder的区别 

**可变性**

简单的来说：`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。

> 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，String 、`StringBuilder` 与 `StringBuffer` 的实现改用 byte 数组存储字符串 `private final byte[] value`

而 `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。

`StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是`AbstractStringBuilder` 实现的，大家可以自行查阅源码。

```
AbstractStringBuilder.java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;

    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }}
```

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。**`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。**

**性能**

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

##  15、讲一下=、==、equals 

**`=`** : 是赋值符号，a=b就是将b赋给a。

**`==`** : 它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象。(**基本数据类型==比较的是值，引用数据类型==比较的是内存地址**)

**`equals()`** : 它的作用也是判断两个对象是否相等，它不能用于比较基本数据类型的变量。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类。

`Object`类`equals()`方法：

```
public boolean equals(Object obj) {
     return (this == obj);
}
```

`equals()` 方法存在两种使用情况：

- 情况 1：类没有覆盖 `equals()`方法。则通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象。使用的默认是 `Object`类`equals()`方法。
- 情况 2：类覆盖了 `equals()`方法。一般，我们都覆盖 `equals()`方法；实现若它们的内容相等，则返回 true(即，认为这两个对象相等)。

##  equals怎么重写的？ 

为什么要重写equals()方法？

Object类中equals()方法的默认实现主要是用于判断两个对象的引用是否相同。而在实际开发过程中，通常需要比较两个对象的对应属性是否完全相同，故需要重写equals()方法。

如何重写equals()方法？

假设equals()方法的形参名为otherObj，稍后需要将其转换为另一个叫做other的变量。

第一步，检测this与otherObj是否引用同一对象：

if(this == otherObject) return true;

第二步，检测otherObj是否为空：

if(otherObject == null) return false;

第三步，判断this与otherObj是否属于同一个类，具体分两种情况：

(1). 如果equals()方法的语义在每个子类中均有所改变，则使用getClass()方法进行检测：

if(getClass() != otherObject.getClass()) return false;

(2). 如果equals()方法在所有子类中均有统一的语义，则使用instanceof关键字进行检测：

if (!(otherObject instanceof ClassName)) return false;

第四步，将otherObj转换为相应类的类型变量：

ClassName other = (ClassName) otherObject;

第五步，对所有需要比较的域进行一一比较，若全匹配则返回true，否则返回false。

关于equals()语义的补充说明：假设现有Employee与Manager两个类，Manager类继承Employee类。若仅将ID作为相等的检测标准，则仅用在Employee类中重写equals()方法，并将该方法声明为final的即可，这就是所谓的「拥有统一的语义」。

重写equals()方法需要注意什么？

归根结底，还是想问equals()方法的主要特性。Java语言规范要求equals()方法具有如下特性：

    自反性：对于任何非空引用x，x.equals(x)应该返回true。
    对称性：对于任何引用x和y，当且仅当y.equals(x) 返回true时，x.equals(y)也应该返回true。
    传递性：对于任何引用x、y和z，如果x.equals(y) 返回true，y.equals(z)返回true，x.equals(z)也应该返回true。
    一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果。
    非空性：对于任何非空引用x，x.equals(null)应该返回false。


## 

 ## 16、讲一下java异常 

异常(Exception)是Java语言提出的一种错误报告模型，这种错误报告模型在程序和客户端之间传递异常问题。
使用异常处理(错误报告模型)的好处显而易见：

* 无论何时，代码都能可靠运行，即使发生异常，程序也能执行而不是停止；
* 异常处理使代码的阅读、编写和调试工作更加方便。

2.异常的种类有哪些？

在Java程序运行期间，由于Java程序导致JVM发生错误的BUG用Error对象来表示，此类BUG发生在运行期且与JVM有关，所以一旦发生将不可恢复，即Java程序停止运行。

在Java语言中，用Throwable对象作为Exception对象和Error对象的父类。其关系如图所示：
![11](https://img-blog.csdnimg.cn/20190708012034555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vYm9keV8x,size_16,color_FFFFFF,t_70)
对于Java程序自身导致的BUG用Exception对象表示，Exception对象在Java程序中是可以提前捕获并处理掉的（这个功能由try-catch-finally完成），以此避免因为一个小BUG导致整个系统停止运行。

Java语言把编译时可能产生的异常称为受检查异常，把运行时可能产生的异常称为不受检查异常。
受检查异常是在编译时，由编译器检测出Java程序可能会抛出的异常；



##  17、讲一下基本数据类型和包装类型的关系 

关系：

基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型（如我们在使用集合类型Collection时就一定要使用包装类型而非基本类型），它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。

另外当需要往ArrayList，HashMap中放东西时，像int，double这种基本类型是放不进去的，因为容器都是装object的，这是就需要这些基本类型的包装器类了。

二者可以相互转换。

区别：

1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是
2、包装类型是引用的传递，基本类型是值的传递
3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间
4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们
5、初始值不同，eg： int的初始值为 0 、 boolean的初始值为false 而包装类型的初始值为null
6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 coolection Map时会使用

##  18、讲一下你知道的修饰符 

1、pubic
使用对象: 类、接口、成员。
介绍：无论所属的包定义在哪，该类（接口、成员）都是可访问的。
2、private
使用对象: 成员。
介绍: 成员只可以在定义它的类中被访问。
3、static
使用对象: 类、方法、变量、初始化函数。
介绍：static修辞的内部类是一个项级类，它和类包含的成员是不相关的。静态方法是类方法，被指向到所属的类面不是类的实例。静态变量是类变量，无论该变量所在的类创建了多少实例，该变量只存在一个实例被指向到所属的类而不是类的实例。初始化函数是
在装载类时执行的，面不是在创建实例时执行的。
4、final
使用对象：类、方法、变量。
介绍：被定义成final的类不允许出现子类，不能被覆盖(不应用于动态查询)，变量值不允许被修改。
5、abstract
使用对象：类、接口、方法。
介绍：abstract类中包括没有实现的方法。不能被实例化。abstract 方法的方法体为空
该方法的实现在子类中被定义，并且包含一个abstract方法的类必须是一个abstact类。
6、protected
使用对象: 成员
介绍：protected 成员只能在定义它的包中被访问，如果在其他包中被访问，则实现这个
方法的类必须是该成员所属类的子类。
7、native
使用对象: 成员。
介绍: 与操作平台相关，定义时并不定义其方法，**方法被个外部的库实现。**
8、synchronized
使用对象: 静态方法、非静态方法、代码块、一个对象、一个类。。
介绍: 不管修饰的是谁，锁的都是synchronized 关键字后面的大括号包起来的部分。这一部分是不能被多线程同时访问的。
哪怕修饰的是对象或者类，只要多个线程执行的时候，不同时执行到对象或类中synchronized 修饰的部分，就可以执行。也就是说，给对象或者类加了锁，同时synchronized修饰的代码块和没有修饰的代码块都是可以的。

9、volatile
使用对象：变量。
介绍：因为异步线程可以访问变量，所以有些优化操作是一定不能作用在变量上的。
volatile有时可以代替synchronized.
10、transient
使用对象: 变量。
介绍。变量不是对象持久状态的一部分，不应该把变量和对象一起串起

## 19、final和static的区别 

### **final** 表示最终的，不可变的

final 可以修饰-类，方法，变量

1. 修饰 **类** -表示类不可变，不可继承，比如 **String** 具有不可变性
2. 修饰 **方法** -表示该方法不可重写，比如 **模板方法**，可以用来固定算法
3. 修饰 **变量** -表示该变量在编译后成为一个 **常量**，不可以被修改

**注意：**

修饰**基本数据类型**，**值本身** 不能被改变

修饰的是**引用类型**，**句柄本身** 或者说 **引用的指向** 是不可变，但对象里面的属性可以改变

### **static** 表示全局的 or 静态的

static 可以修饰-方法，变量，代码块

在JVM中，被static修饰的方法和变量存放在方法区中（JDK8称为元空间），它属于全局共享的，而不是某个线程私有的。

也就是独立于该类中的任何对象，它不依赖于类的特定实例（对象），被类的所有实例共享，可以直接用类名调用类中的任何方法和变量。

![img](https://pic3.zhimg.com/80/v2-4e20f3b8e2409828251243b67f5da9e6_720w.jpg)

## 讲一下数据结构中树结构的演变，以及每个结构的缺点都有哪些 

  **普通二叉树（并非B 树）** 

  ![img](https://images2015.cnblogs.com/blog/544496/201707/544496-20170719102331536-1343072049.jpg) 

​    

  **平衡二叉树**，在最坏情况下，插入的次序已经是有序的，此时二叉查找树将成为一棵斜树，它的搜索性能已经是线性的了，查找的效率骤然下降，时间复杂度边为O（n），所以二叉查找树的效率介于 O（logN）和O（n）之间。此时可以使用平衡二叉树提高查找效率： 

  　　1.根节点的左子树和右子树的深度最多相差 1； 

  　　2.根节点的左子树和右子树叶都是一棵平衡二叉树。 

​    

  　　实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略。 

  　　构造平衡二叉树的思想：  即让二叉树的左右子树深度差不超过1，在构造二叉查找树的过程中，每当插入一个结点，首先检查插入后是否破坏了树的平衡性，若破坏对树进行调整，使插入后成为平衡二叉树。这就需要对节点进行旋转，也就是当某个节点的左右子树深度超过1时需要对这个节点进行旋转（旋转之后依旧是左子树小于节点小于右子树），重新调整树的结构

  ![img](https://images2015.cnblogs.com/blog/544496/201707/544496-20170719102409021-1812509703.png) 

​    

  **B树、B-树，多路搜索树（平衡多路查找树）**当数据规模大到内存已不足以容纳时（此时就需要存放在外存中），常规平衡二叉搜索树的效率将大打折扣。其原因在于，查找过程对外存的访问次数过多。例如，若将 109（1 billion = 10 亿）个记录在外存中组织为 AVL 时，则每次查找大致都需要做 30 次外存访问，此时可以使用多路搜索树。 

  　　概念： 

　　　　每个结点孩子个数可以 > 2，多路就是指子树超过 2 个；

　　　　每个结点可以存储多个数据元素，即容纳多个值；

　　　　除非数据已经填满，否则不会增加新的层。也就是说，B树追求"层"越少越好。

　　　　子结点中的值，与父结点中的值，有严格的大小对应关系。一般来说，如果父结点有a个值，那么就有a+1个子结点。比如，父节点有两个值（7和16），就对应三个子结点，第一个子结点都是小于7的值，最后一个子结点都是大于16的值，中间的结节点就是7和16之间的值。

　　提高效率：原理

　　　　每个节点存放多个元素，降低树的深度，避免树的深度过大导致磁盘IO过于频繁而导致查询效率低下。

　　　　每一次磁盘的访问我们都可以获得最大量的数据。每个节点可以具有比二叉树多得多的元素，减少了必须访问节点和数据块的数量，从而提高了性能。可以说B树的数据结构就是为内外存的数据交互准备的。

　　　　所以根据以上讲解，当我们在设计Ｂ树结构的时候，可以将Ｂ树中每个结点存放数据的个数与硬盘的盘块容量做匹配，保证一次性获取尽可能多的数据，获取数据后在内存中我们可以使用拆半查找等算法进行内存查找操作。

　　意义：

  　　　　用树对硬盘、磁带等二级存储设备上读写数据时，会有问题。I/O操作的基础单元是block，当需要从硬盘上读数据时，包含该数据的整个block都会读进内存。而二叉树的节点可能不在同一个block里，这样对树进行遍历时，就会进行多次的block更换。 

  　　　　B-Tree就能减少访问二级存储的时间，具体的原理是：B-Tree的一个节点可以有多个数据值，数据值总大小等于block，这样就可以充分利用每次读取的block，进行多个数值的比较。 

   　　　在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取/写入块(block)中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是B-tree结构，以及相关的变种结构：B+-tree结构和B*-tree结构。 

  　　  ![img](https://images2015.cnblogs.com/blog/544496/201707/544496-20170719103135130-1790680504.png) 

　　文件查找的具体过程(涉及磁盘IO操作)，为了简单，上图用少量数据构造一棵3叉树的形式，实际应用中的B树结点中关键字很多的。上图中比如根结点，其中17表示一个磁盘文件的文件名；小红方块表示这个17文件内容在硬盘中的存储位置；p1表示指向17左子树的指针。
　　假如每个盘块可以正好存放一个B树的结点（正好存放2个文件名）。那么一个结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。
　　模拟查找文件29的过程：
　　　　根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作 1次】
　　　　此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17<29<35，因此我们找到指针p2。
　　　　根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】
　　　　此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26<29<30，因此我们找到指针p2。
　　　　根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】
　　　　此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。
　　分析上面的过程，发现需要3次磁盘IO操作和3次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。
　　如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘4次，最多5次，而且文件越多，B树比平衡二叉树所用的磁盘IO操作次数将越少，效率也越高。

**B+树，也是一种多路搜索书：**

　　Ｂ树的变种；

　　**分支结点只存索引，不存具体数据；**

　　叶子结点包含所有数据，并且包含叶子结点本身按着关键字大小自小而大顺序连接；

　　为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？

　　　　B+-tree的磁盘读写代价更低
　　　　B+-tree 的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B  树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。
　　　　B+-tree的查询效率更加稳定，由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

## 面向对象特征？ 

1.**抽象**
2.**继承**
3.**封装**
4.**多态**

-抽象：将拥有共同特征的一类事物用类来描述。

-继承：子类继承父类的属性。当多个类中定义了相同的共性内容(相同的成员变量和成员方法)时，为了提高代码的复用性，就将这多个类中相同的共性内容抽取出来定义在一个独立的类中，然后再使用其它类去继承这个定义了相同的共性内容的独立的类，就继承了这独立类中所定义的相同的共性内容了，这就是继承。

-封装：封装数据和对数据的操作，对外提供一个最简单的接口。

-多态：父类对象对子类对象的引用。

## 接口和抽象类区别？使用场景？ 

一、抽象类和接口在语法上的异同：

1、相同点

    都不能被实例化

2、不同点     

    第一点． 接口是抽象类的变体，接口中可以定义一些方法，但是不能实现。
    第二点． 每个类只能继承一个抽象类，但是可以实现多个接口
    第三点． 抽象类可以实现部分方法。但是接口中方法必须为public修饰的、抽象类不能实现具体的方法。
    第四点． 接口中基本数据类型为static 而抽象类不是的。 


二、应用场景

相同点没有什么可说的，我们从不同点下手。


1、第一个重要的不同点就是，

    抽象类中不一定都是抽象的方法，也可以有具体实现的方法，这样就可以把大家公用的方法提升到抽象类中，然后具体的方法可以留给子类自己实现（此处经典的应用，模板方法设计模式）。所以抽象类可以更好的实现代码的复用


2、另一个重要的不同就是类可以实现多个接口。

    接口和抽象类的概念不一样。这个可以理解为接口是对动作的抽象，抽象类是对根源的抽象（即对本质的抽象与其他类的本质不同）。

**抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么**。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.

所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。

当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。

    另一个重要的概念就是多态，多态通过分离做什么和怎么做，从另一个角度将接口和实现分离出来。多态不但能够改善代码的组织结果和可读性，还能创建可扩展的程序----即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序。由于接口更关注于动作的实现，多态主要是分离“做什么”和“怎么做”，所以接口的另一个重要的应用就是多态的实现（当然抽象类也可以实现多态，但是接口更加合适）。


    抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度的。

## String、StringBuilder、StringBuffer区别？ 

**可变性**

简单的来说：`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以`String` 对象是不可变的。

> 补充（来自[issue 675](https://github.com/Snailclimb/JavaGuide/issues/675)）：在 Java 9 之后，String 、`StringBuilder` 与 `StringBuffer` 的实现改用 byte 数组存储字符串 `private final byte[] value`

而 `StringBuilder` 与 `StringBuffer` 都继承自 `AbstractStringBuilder` 类，在 `AbstractStringBuilder` 中也是使用字符数组保存字符串`char[]value` 但是没有用 `final` 关键字修饰，所以这两种对象都是可变的。

`StringBuilder` 与 `StringBuffer` 的构造方法都是调用父类构造方法也就是`AbstractStringBuilder` 实现的，大家可以自行查阅源码。

```
AbstractStringBuilder.java
abstract class AbstractStringBuilder implements Appendable, CharSequence {
    /**
     * The value is used for character storage.
     */
    char[] value;

    /**
     * The count is the number of characters used.
     */
    int count;

    AbstractStringBuilder(int capacity) {
        value = new char[capacity];
    }}
```

**线程安全性**

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。**`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。**

**性能**

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

## 深拷贝、浅拷贝？

深拷贝，就是在对某个对象进行拷贝的时候，如果这个对象持有其他对象的引用，在拷贝的时候会将要拷贝的对象以及引用的对象，一起拷贝。

而浅拷贝只拷贝当前对象和持有的索引，不拷贝索引指向的对象。

深拷贝会在内存区域中重新开辟一块区域，用来存放这个对象持有的其他对象的数据，也就是将这个持有的数据中的内容，全部抄一份到这个新的内存区域中。

