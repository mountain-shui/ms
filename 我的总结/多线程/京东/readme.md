  ## 3.Java多线程 

### ThreadLocal原理？内存泄漏问题？使用场景？ 

**1.ThreadLocal 是什么？**

ThreadLocal 是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，适用于各个线程不共享变量值的操作。

**2.ThreadLocal 工作原理是什么？**

ThreadLocal 原理：每个线程的内部都维护了一个 ThreadLocalMap，它是一个 Map（key,value）数据格式，key 是一个弱引用，也就是 ThreadLocal 本身，而 value 存的是线程变量的值。

也就是说 ThreadLocal 本身并不存储线程的变量值，它只是一个工具，用来维护线程内部的 Map，帮助存和取变量。

数据结构，如下图所示：

![img](https://pic2.zhimg.com/80/v2-aaba364d9af11719667ffc9ab6b64dad_720w.jpg)

## 

**内存泄漏**

ThreadLocalMap中的key是弱引用，而value是强引用。

**注意弱引用的对象如果被其他的强引用所引用，GC不会回收。**

所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收时，key会被清空掉，而value不会。ThreadLocal中就会出现key为null的Entry。假如我们不采取措施，value永远不会被GC回收，这个时候就可能会产生内存泄漏问题。
ThreadLocalMap实现中已经考虑了这种情况，在调用set()、get()、remove()方法时会处理掉key为null的记录。使用ThreadLocal时，最好手动调用remove()方法。

内存泄露的问题不是因为强引用或者弱引用，不管是什么样的引用方式，只要当前线程的引用存在，这个entry就不会被GC。

内存泄漏的两个必要条件是：

* 栈中thread local引用没断开。
* 栈中当前线程没有结束。

**使用场景**

实际开发中我们真正使用`ThreadLocal`的场景还是比较少的，大多数使用都是在框架里面。

最常见的使用场景的话就是用它来解决数据库连接、`Session`管理等保证每一个线程中使用的数据库连接是同一个。

还有一个用的比较多的场景就是用来解决`SimpleDateFormat`解决线程不安全的问题，不过现在`java8`提供了`DateTimeFormatter`它是线程安全的，感兴趣的同学可以去看看。

  ### 1.开启线程的方法与各自的优劣

**创建线程的三种方法 **

  * 继承Thread类，重写run()方法
  * 实现Runnable接口，重写run()方法
  * 实现Callable接口，重写call()方法

**优劣：**

继承Thread类

​	优点：编程简单，访问当前线程直接使用this关键字

​	缺点：继承了Thread类就不能继承其他类了

实现Runnable接口

​	优点：可以让多个线程共享一个资源，实现代码和资源的分离，实现这个接口还可以继承其他的类。

​	缺点：访问当前线程需要使用Thread.currentThread()方法。

Runnable和Callable的区别

* Runnable使用run()方法，Callable使用call()方法
* Runnable有返回值，Callable没有返回值
* Runnable不能返回异常，Callable可以返回异常

start和run的区别：

​		运行start表示创建一个新线程，调用run()方法，在main线程中运行run()方法不会创建线程，就相当于普通		的方法调用。

 ### 2.线程池的状态

![08000847-0a9caed4d6914485b2f56048c668251a](images\08000847-0a9caed4d6914485b2f56048c668251a.jpg)

**1.RUNNING**：这是最正常的状态，接受新的任务，处理等待队列中的任务。线程池的初始化状态是RUNNING。线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。

**2.SHUTDOWN**：不接受新的任务提交，但是会继续处理等待队列中的任务。调用线程池的shutdown()方法时，线程池由RUNNING -> SHUTDOWN。

**3.STOP**：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程。调用线程池的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

**4.TIDYING**：所有的任务都销毁了，workCount 为 0，线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()。因为terminated()在ThreadPoolExecutor类中是空的，所以用户想在线程池变为TIDYING时进行相应的处理；可以通过重载terminated()函数来实现。 

当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。

当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

**5.TERMINATED**：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

  ### 3.线程池的参数 

**最重要的三个参数**

* corePoolSize:线程池正常运行时，存在的最小的线程数量，即使这些线程空闲，也不会被销毁。
* maximunPoolSize:最大线程池数量，一个任务提交到线程池，当前没有线程空闲，就会将这个刚提交的线程放到工作队列的队尾，等待执行，如果队列已经满了，就在线程池中创建一个新的线程，当然不能无限创建，这个参数就是用来限定可以线程池中最多乐意创建多少线程的。
* keepAliveTime:当超出corePoolSize数量之外的线程空闲，并且经过keepAliveTime还没有新的任务，就会自动销毁。

**其他参数**

* unit:keepAliveTime的计时单位。
* workQueue:新任务被提交后，会先进入到此工作队列中，任务调度时再从队列中取出任务
* threadFactory:线程的创建工厂。
* handler:拒绝策略，当工作队列中的任务已经达到最大限制，并且线程池的线程数量也达到了最大数量，就会启动拒绝策略

对于workQueue，jdk提供了四种工作队列：

* ArrayBlockingQueue:有限数组阻塞队列，FIFO队列，有新任务进入时，先放到队尾，如果队列已满，就创建一个新的线程，如果线程已经达到maximunPoolSize就会执行拒绝策略。
* ②LinkedBlockingQuene:有限的链表阻塞队列，FIFO，最大队列长度为integer.MAX，当达到corePoolSize时就会将新任务放到队列，并不会创建新的线程，相当于maximunPoolSize不起作用。
* SynchronousQueue:一个不缓存任务的阻塞队列，新任务不会被缓存，有任务直接会被执行，当线程达到最大线程数时，直接执行拒绝策略。
* PriorityBlockingQueue:具有优先级的无界阻塞队列，按照优先级进行调度。

handler有四种：

* CallRunsPolicy:直接执行被拒绝者的run方法
* AbortPolicy:丢弃任务并且抛出异常。
* DiscardPolicy:直接丢弃，什么都不做。
* DiscardOldPolicy:丢弃最早加入队列的任务，把这个任务放进去。



  ### 4.线程池新建线程的流程 

![68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f2545352539422542452545382541372541332545372542412542462545372541382538422545362542312541302545352](images\68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d372f2545352539422542452545382541372541332545372542412542462545372541382538422545362542312541302545352.png)

### 5.保证线程安全的几种方法 

 **1.Synchronized**

线程同步,表示当多个线程同时使用的是一个对象的时候,sync只让一个运行,其他的必须等待

    多个线程在同时运行的时候如果访问的不是不同对象那么他们就是线程安全的,否则就使用sync,来保证线程的同步运行

sync几种方式
1 class 锁
2 方法锁
3 代码块锁

**2.ReentrantLock**

他实现了Lock接口, lock接口是jdk1.5的时候出来的,他实现结果跟sync是一个道理,不过他是finally来释放锁的

    sync是jvm层面,lock是类层面,sync锁状态不可以判断,Lock的锁状态可以判断,sync不可中断, lock可以中断也有公平锁

ReentrantLock 总共实现两种方式,公平锁和非公平锁

**3.Atomic**

原子性

**4.Wait和Notify**

消息通知

## 多个线程操作volatile变量的过程 

 JVM中有一个内存区域是jvm虚拟机栈，每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问某一个对象值的时候，首先通过对象的引用找到对应在堆内存的变量的值，

然后把堆内存变量的具体值load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，

在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量。这样在堆中的对象的值就产生变化了。

下面一幅图描述对变量一次写操作的过程。

 

[![java volatile1](https://images.cnblogs.com/cnblogs_com/aigongsi/201204/201204011757235219.jpg)](http://images.cnblogs.com/cnblogs_com/aigongsi/201204/201204011757234696.jpg)

 

 

（1）read and load 从主存复制变量到当前工作内存
（2）use and assign 执行代码，改变共享变量值 
（3）store and write 用工作内存数据刷新主存相关内容

这一些操作并不是原子性，也就是 在read load之后，如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，所以计算出来的结果会和预期不一样

对于volatile修饰的变量，**jvm虚拟机只是保证从主内存加载到线程工作内存的值是最新的**

例如假如线程1，线程2 在进行read,load 操作中，发现主内存中count的值都是5，那么都会加载这个最新的值

在线程1堆count进行修改之后，会write到主内存中，主内存中的count变量就会变为6

线程2由于已经进行read,load操作，在进行运算之后，也会更新主内存count的变量值为6

但是，本应该是count的值进行两次递增＋1,要递增到8，可是显示的结果却是6

导致两个线程及时用volatile关键字修改之后，还是会存在并发的情况。volatile修饰的变量，并不能控制并发，只是做到了可见。

## 乐观锁与悲观锁？使用场景？乐观锁如何实现？ 

1.悲观锁（一般都是通过锁机制来实现的）

（1）每次去拿数据都会认为别人会修改，所以每次拿数据的时候都会上锁。比如：行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

2.乐观锁

（1）每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，如果发生冲突了，则返回用户的错误信息，让用户决定如何去做。（适用于多读的类型，并发大的情况。一般基于数据版本号实现）

（2）冲突检测和数据更新(版本号机制实现)

在数据表中加上一个数据版本号version字段，表示数据被修改的次数，数据被修改时version值会加1，当更新数据时，刚才读到的version值和数据库中的version值相等才可以更新。

update table set x=x+1, version=version+1 where id=#{id} and version=#{version};

（3）CAS（compare and swap）实现

多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新值，其他的线程失败，但不会被挂起，而是被告知这次竞争失败，并可以再次尝试。

CAS 操作原理:

CAS 操作中包含三个操作数 —— 需要读写的内存位置（V）、进行比较的预期原值（A）和拟写入的新值(B)。如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B。否则处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。
**乐观锁及悲观锁的应用场景**

1.什么时候使用悲观锁？

**写入频繁使用悲观锁**，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。

一旦通过悲观锁锁定一个资源，那么其他需要操作该资源的使用方，只能等待直到锁被释放，好处在于可以减少并发，但是当并发量非常大的时候，由于锁消耗资源，并且可能锁定时间过长，容易导致系统性能下降，资源消耗严重。

2.什么时候使用乐观锁？

**读取频繁使用乐观锁**，一般乐观锁只用在高并发、多读少写的场景。比如，GIT,SVN,CVS等代码版本控制管理器。

例如：A、B，同时从SVN服务器上下载了hello.java文件，当A完成提交后，此时B再提交，那么会报版本冲突，此时需要B进行版本处理合并后，再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁，那么意味者所有程序员都必须一个一个等待操作提交完，才能访问文件，这是难以接受的。