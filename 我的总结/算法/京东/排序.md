## 归并排序和快速排序，它们的区别是什么，分别适用于什么场景

### 快速排序

**概述**

快速排序算法借鉴的是二叉树前序遍历的思想，最终对数组进行排序。

**优点：**

对于数据量比较大的数组排序，由于采用的具有二叉树二分的思想，故排序速度比较快

**局限**

只适用于顺序存储结构的数据排序（数组 ，ArrayList等），不适用于链式的数据结构

**算法实现思路**

一.将目标数组转化为这样一个数组。数组中的某个位置左边的所有数据都比该位置的数据小，该位置右边的数据都比该位置数据大。

**实现思路：**

1.取出数组第0个数据

 

![img](https://upload-images.jianshu.io/upload_images/13006499-c4d56d4143f4a735.png)

 

2.从数组最右边开始遍历，如果遍历位置的数据比第0个位置的数据小，将该位置的数据赋值给左边指针停留下的位置。

 

![img](https://upload-images.jianshu.io/upload_images/13006499-47514d4be6f7f525.png)

3.改变遍历方向，从左边开始开始遍历，如果发现左边的数据比第0个位置的数据大，将该位置的数据赋值给2步骤停留下来的位置，并变换方向。

![img](https://upload-images.jianshu.io/upload_images/13006499-9956afd0a864392d.png)

 

4.循环2、3步骤直到左右遍历到的下标重合
 5.将取出的第0个位置的值赋值给循环结束后左右指针停留下的位置

二. 借鉴前序遍历的思路，递归，最终完成排序。

**代码实现**

```java
	private void quickSort(int[] array, int start, int end){
        if(start >= end){
            return;
        }
        int key = array[start];
        int left = start;
        int right = end;
        while(left < right){
            while(left < right && array[right] > key){
                right--;
            }
            if(array[right] < key){
                array[left++] = array[right];
            }
            while(left < right && array[left] < key){
                left++;
            }
            if(array[left] > key){
                array[right--] = array[left];
            }
        }
        array[left] = key;
        quickSort(array, start, left - 1);
        quickSort(array, left + 1, end);

    }
```

```java
 	public void main(String[] args) {
        int[] array = {1, 5, 0, 11 , 6, 7};
        quickSort(array, 0, array.length - 1);
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }
```

### 归并排序

**概述**

归并排序与快速排序相同，同样是借鉴二叉树的思想，时间复杂度O(n),与快速排序一样是大量数据排序的最优方式之一。

**思路分析**

归并排序是将目标数组分成左右两个数组，左右两个数组必须是有序的，然后对这两个数组合并从而实现排序。对于任意的数组都可以将所有的数据分成若干个数组，每个数组中都只有一个元素，然后两两合并。（因此，归并排序的内存开销会比快速排序多）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200713100808351.gif#pic_center)

**代码实现**

```java
 //归并排序
    //拿{5,1,4,2,3}来举例
    public void MergeSort(int[] a, int left, int right){
        int mid = (left+right)/2;
        if(left >= right){          //当分到数组只剩一个元素时,即left==right停止
            return;
        }
        //将数组分为左右两部分
        //第一次递归分为{5,1,4},{2,3}
        //递归结果的左边部分再次递归分为{5,1},{4}
        //递归结果的左边部分再次递归分为{5},{1}
        MergeSort(a,left,mid);//数组左部分排序
        MergeSort(a,mid+1,right);//数组右部分排序

        //退一层递归{5 | 1}进入下面函数后，排序成{1,5}；
        //再退一层递归{1,5 | 4}进入下面函数，排序成{1,4,5};右部分数组{2 | 3}进入下面函数排序成{2,3}
        //再退一层递归{1,4,5 | 2,3}进入下面函数，排序成{1,2,3,4,5}
        Merge(a,left,mid,right);
    }

    private void Merge(int[] a, int left, int mid, int right) {
        int i = left;
        int j = mid+1;
        int[] temp = new int[a.length];       //创建临时数组存储排序后的结果
        int tempIndex = 0;
        while(i <= mid && j <= right){          //取左右两边数组中小的那个值放入临时数组。拿{1,5},{4}情况举例的话
            if(a[i] > a[j]){                    //第一次循环，左边数组元素1比右边数组元素4小，1被放入临时数组，i++
                temp[tempIndex++] = a[j++];     //第二次循环，左边数组元素5比右边数组元素4大，4被放入临时数组，j++
            }else{
                temp[tempIndex++] = a[i++];
            }
        }
        while(i <= mid){                        //放完临时数组后，左边数组有剩余元素的情况，例如上述情况，左边数组剩余元素5放入临时数组
            temp[tempIndex++] = a[i++];
        }
        while(j <= right){                      //放完临时数组后，右边数组有剩余元素的情况，大致同上
            temp[tempIndex++] = a[j++];
        }
        for(int k = 0; k < tempIndex; k++) {    //将排序好的临时数组赋值给原数组
            a[k + left] = temp[k];
        }
    }
```

```java
@Test
2     public void testMergeSort() {
3         int[] array = new int[]{1, 3, 4, 10, 2, 5, 6, 9, 7, 8};
4         mergeSort(array, 0, array.length - 1);
5         for (int i = 0; i < array.length; i++) {
6             System.out.println(array[i]);
7         }
8     }
```

1.**快速排序**是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是**随机分布**时，快速排序的平均时间最短
 2.**堆排序**所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，适合**超大数据量**。这两种排序都是不**稳定的**。
 3.若要求**排序稳定**，则可选用**归并排序**。

 ## 八大排序,,,,,基本时间复杂度，讲了一些排序的思路

冒泡排序：从左到右将元素进行比较，大的移动到右边，小的换到左边，重复这个动作，直到在一次排序中，没有任何元素进行交换。

快速排序：每次找到一个元素在该数组中的位置，则该元素左边的一定比它小，右边的一定比它大，左右两个数组再进行如上的操作。直到数组不可再分。

直接插入排序：每趟将一个待排序的记录，按照其关键字的大小，**插入到有序队列的合适位置**，直到全部插入完成

希尔排序：将整个待排序元素序列分割成若干子序列（这些子序列是通过相隔增量的元素组成），对这些序列进行插入排序，然后缩减这个增量，直到某次增量足够小，就对全体元素进行一次插入排序。

简单选择排序：每次从待排序列中选出最小元素，**如果最小元素不是待排序列的第一个元素，就进行交换**，从余下的N-1个元素中，找出关键字最小的元素，重复上述，直到结束。

堆排序：根据堆的性质进行的排序，当是大根堆时，任何父节点的值都大于子节点的值，对于小根堆，任何父节点的值都小于子节点的值。每次将第一个元素和最后一个元素交换，输出最后一个元素。把剩下的堆元素进行调整。重复上述，直到堆中没有元素。

归并排序：将序列分为N个子序列，每个子序列元素个数为1，然后两两归并进行排序，然后再将子序列两两归并，直到最后归并为一个序列。

基数排序：将所有数统一成相同的数位长度，不够长的前面补0，进行从低位到高位的排序，排序完成就变成了有序序列。

![1342700879_2982](G:\王鹏\面试\https\牛客面经\京东\images\1342700879_2982.jpg)

总结：

平均时间复杂度较低的O(NlogN)：快排，希尔排序，堆排序，归并排序，

稳定的：直接插入，冒泡，归并，基数。

##  口述 二分查找的思路 

假设有一个升序的集合，先比价待查找数是否大于集合的中位数，如果大于中位数，则待查找数再中位数右边，反之在左边，再查看是否大于右边数组的中位数，重复上述直到找到，没找到返回-1.

##  口述 如何计算一个字符串形式的 数学表达式（计算器） 

需要两个栈，一个是数字栈，一个是操作符栈。

1.从左到右顺序扫描表达式的每一个字符。
2.如果是操作数 则直接压入数字栈。
3.如果是操作符 则根据符号栈的当前状态来决定怎么处理这个符号。
处理运算符的过程：
|- 如果当前符号栈为空,则直接将该运算符压入符号栈。
|- 如果当前符号栈栈顶符号是左括号‘(’则也直接将该运算符压入符号栈。
|- 如果当前符号栈栈顶符号的优先级<该运算符,还是直接将该运算符压栈。
|- 如果当前符号栈栈顶符号的优先级>=该运算符,则将栈顶运算符(OP)取出来,接着从数字栈中取2个数b、a,然后将a(OP)b的结果压入数字栈中。
|- 如果当前符号是右括号‘)’,则不将它压入栈,而是不断从2个栈中,弹出1个符号和2个操作数,然后将运算结果压入数字栈 ,直到遇到左括号‘(’。
|- 然后继续向表达式的后面扫描,直到表达式结束。
当表达式解析结束的时候，若符号栈不为空，则不断的从符号栈和数字栈中弹出元素，进行计算。
当符号栈为空后,数字栈栈顶元素就是最后的结果。