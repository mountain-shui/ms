## 归并排序和快速排序，它们的区别是什么，分别适用于什么场景

### 快速排序

**概述**

快速排序算法借鉴的是二叉树前序遍历的思想，最终对数组进行排序。

**优点：**

对于数据量比较大的数组排序，由于采用的具有二叉树二分的思想，故排序速度比较快

**局限**

只适用于顺序存储结构的数据排序（数组 ，ArrayList等），不适用于链式的数据结构

**算法实现思路**

一.将目标数组转化为这样一个数组。数组中的某个位置左边的所有数据都比该位置的数据小，该位置右边的数据都比该位置数据大。

**实现思路：**

1.取出数组第0个数据

 

![img](https://upload-images.jianshu.io/upload_images/13006499-c4d56d4143f4a735.png)

 

2.从数组最右边开始遍历，如果遍历位置的数据比第0个位置的数据小，将该位置的数据赋值给左边指针停留下的位置。

 

![img](https://upload-images.jianshu.io/upload_images/13006499-47514d4be6f7f525.png)

3.改变遍历方向，从左边开始开始遍历，如果发现左边的数据比第0个位置的数据大，将该位置的数据赋值给2步骤停留下来的位置，并变换方向。

![img](https://upload-images.jianshu.io/upload_images/13006499-9956afd0a864392d.png)

 

4.循环2、3步骤直到左右遍历到的下标重合
 5.将取出的第0个位置的值赋值给循环结束后左右指针停留下的位置

二. 借鉴前序遍历的思路，递归，最终完成排序。

**代码实现**

```java
	private void quickSort(int[] array, int start, int end){
        if(start >= end){
            return;
        }
        int key = array[start];
        int left = start;
        int right = end;
        while(left < right){
            while(left < right && array[right] > key){
                right--;
            }
            if(array[right] < key){
                array[left++] = array[right];
            }
            while(left < right && array[left] < key){
                left++;
            }
            if(array[left] > key){
                array[right--] = array[left];
            }
        }
        array[left] = key;
        quickSort(array, start, left - 1);
        quickSort(array, left + 1, end);

    }
```

```java
 	public void main(String[] args) {
        int[] array = {1, 5, 0, 11 , 6, 7};
        quickSort(array, 0, array.length - 1);
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }
```

### 归并排序

**概述**

归并排序与快速排序相同，同样是借鉴二叉树的思想，时间复杂度O(n),与快速排序一样是大量数据排序的最优方式之一。

**思路分析**

归并排序是将目标数组分成左右两个数组，左右两个数组必须是有序的，然后对这两个数组合并从而实现排序。对于任意的数组都可以将所有的数据分成若干个数组，每个数组中都只有一个元素，然后两两合并。（因此，归并排序的内存开销会比快速排序多）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200713100808351.gif#pic_center)

**代码实现**

```java
 //归并排序
    //拿{5,1,4,2,3}来举例
    public void MergeSort(int[] a, int left, int right){
        int mid = (left+right)/2;
        if(left >= right){          //当分到数组只剩一个元素时,即left==right停止
            return;
        }
        //将数组分为左右两部分
        //第一次递归分为{5,1,4},{2,3}
        //递归结果的左边部分再次递归分为{5,1},{4}
        //递归结果的左边部分再次递归分为{5},{1}
        MergeSort(a,left,mid);//数组左部分排序
        MergeSort(a,mid+1,right);//数组右部分排序

        //退一层递归{5 | 1}进入下面函数后，排序成{1,5}；
        //再退一层递归{1,5 | 4}进入下面函数，排序成{1,4,5};右部分数组{2 | 3}进入下面函数排序成{2,3}
        //再退一层递归{1,4,5 | 2,3}进入下面函数，排序成{1,2,3,4,5}
        Merge(a,left,mid,right);
    }

    private void Merge(int[] a, int left, int mid, int right) {
        int i = left;
        int j = mid+1;
        int[] temp = new int[a.length];       //创建临时数组存储排序后的结果
        int tempIndex = 0;
        while(i <= mid && j <= right){          //取左右两边数组中小的那个值放入临时数组。拿{1,5},{4}情况举例的话
            if(a[i] > a[j]){                    //第一次循环，左边数组元素1比右边数组元素4小，1被放入临时数组，i++
                temp[tempIndex++] = a[j++];     //第二次循环，左边数组元素5比右边数组元素4大，4被放入临时数组，j++
            }else{
                temp[tempIndex++] = a[i++];
            }
        }
        while(i <= mid){                        //放完临时数组后，左边数组有剩余元素的情况，例如上述情况，左边数组剩余元素5放入临时数组
            temp[tempIndex++] = a[i++];
        }
        while(j <= right){                      //放完临时数组后，右边数组有剩余元素的情况，大致同上
            temp[tempIndex++] = a[j++];
        }
        for(int k = 0; k < tempIndex; k++) {    //将排序好的临时数组赋值给原数组
            a[k + left] = temp[k];
        }
    }
```

```java
@Test
2     public void testMergeSort() {
3         int[] array = new int[]{1, 3, 4, 10, 2, 5, 6, 9, 7, 8};
4         mergeSort(array, 0, array.length - 1);
5         for (int i = 0; i < array.length; i++) {
6             System.out.println(array[i]);
7         }
8     }
```

1.**快速排序**是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是**随机分布**时，快速排序的平均时间最短
 2.**堆排序**所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况，适合**超大数据量**。这两种排序都是不**稳定的**。
 3.若要求**排序稳定**，则可选用**归并排序**。