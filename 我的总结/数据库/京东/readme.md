 ### 1.数据库事务 

事务是逻辑上的一组操作，要么都执行，要么都不执行。

当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。



  ### 2.建立索引的注意事项 

**最左前缀原则**

 如果有一个 2 列的索引 (col1, col2)，则已经对 (col1)、(col1, col2) 上建立了索引；
 如果有一个 3 列索引 (col1, col2, col3)，则已经对 (col1)、(col1, col2)、(col1, col2, col3) 上建立了索引

**选择合适的字段**

* 1.不为 NULL 的字段

索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。

* 2.被频繁查询的字段

我们创建索引的字段应该是查询操作非常频繁的字段。

* 3.被作为条件查询的字段

被作为 WHERE 条件查询的字段，应该被考虑建立索引。

* 4.被经常频繁用于连接的字段

经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**不合适创建索引的字段** 

* 1.被频繁更新的字段应该慎重建立索引

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

* 2.不被经常查询的字段没有必要建立索引

* 3.尽可能的考虑建立联合索引而不是单列索引

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗  B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

* 4.注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city  ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

* 5.考虑在字符串类型的字段上使用前缀索引代替普通索引

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

(前缀索引:定义字符串的一部分当做索引，而不是把整个字符串当做索引。)

**使用索引一定能提高查询性能吗?**

大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。

  ### 3.sql如何拼接语句 

????

###  数据库优化的注意事项 

* SQL语句优化
* 正确使用索引
* 合理的数据库设计，三范式
* 硬件优化
* 分表，分库
* 主从，读写分离
* 缓存

##  5、你使用过mysql，你对mysql有哪些经验，提示了从优化方面进行回答 

a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。
c. mysql库主从读写分离。
d. 找规律分表，减少单表中的数据量提高查询速度。
e.添加缓存机制，比如memcached，apc等。
f. 不经常改动的页面，生成静态页面。
g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.

 

### 实践中如何优化MySQL

最好是按照以下顺序优化：

1. SQL语句及索引的优化

2. 数据库表结构的优化
3. 系统配置的优化
4. 硬件的优化

### SQL语句优化有哪些方法？（选择几条）

（1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。

（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。

（3） 避免在索引列上使用计算

（4）避免在索引列上使用IS NULL和IS NOT NULL

（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。

（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描

（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描

### 优化数据库的方法

1.  选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置NOTNULL，例如’省份’、’性别’最好适用ENUM
2.  使用连接(JOIN)来代替子查询
3.  适用联合(UNION)来代替手动创建的临时表
4.  事务处理
5.  锁定表、优化事务处理
6.  适用外键，优化锁定表
7.  建立索引
8.  优化查询语句



## 8、介绍一下mysql索引 

索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据

常见的MySQL主要有两种结构：Hash索引和B+ Tree索引，mysql默认是InnoDB引擎，默认的是B+树

InnoDB支持3种常见索引，就是 B+ 树索引，哈希索引，全文索引。

#### B+树索引

1、B+树中的B不是代表的二叉（Binary） ，而是代表平衡（Balance），因为B+树是从最早的平衡二叉树演化而来，但是B+树不是一个二叉树。

2、B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有的记录节点都是按照键值大小顺序存在同一层的叶子节点，由叶子节点指针进行相连。

3、B+树在数据库中的特点就是高扇出，因此在数据库中B+树的高度一般都在2~4层，这也就是说查找一个键值记录时，最多只需要2到4次IO,当前的机械硬盘每秒至少可以有100次IO，2~4次IO意味着查询时间只需要0.02~0.04秒。

4、B+树索引并不能找到一个给定键值的具体行，B+树索引能找到的只是被查找的键值所在行的页，然后数据库把页读到内存，再内存中进行查找，最后找到要查找的数据。

5、数据库中B+树索引可以分为，聚集索引和非聚集索引，但是不管是聚集索引还是非聚集索引，其内部都是B+树实现的，即高度是平衡的，叶子节点存放着所有的数据，聚集索引和非聚集索引不同的是，叶子节点是否存储的是一整行信息。每张表只能有一个聚集索引。

6、B+树的每个数据页（叶子节点）是通过一个双向链表进行链接，数据页上的数据的顺序是按照主键顺序存储的。

#### 哈希索引

InnoDB存储引擎使用哈希算法来对字典进行查找，哈希碰撞采用转链表解决，哈希函数采用除法散列方式。

#### 全文检索

全文检索使用倒排索引来实现，倒排索引同B+树索引一样，也是一种数据结构，它在辅助表中存储了单词与单词自身在一个或多个文档中所在位置的映射，这通常利用关联数组实现。

倒排索引它需要将分词（word）存储在一个辅助表（Auxiliary Table）中，为了提高全文检索的并行性能，共有6张辅助表。辅助表中存储了单词和单词在各行记录中位置的映射关系。它分为两种：**倒排文件索引，详细倒排索引**

1、inverted file index（**倒排文件索引**），表现为{单词，单词所在文档ID}

2、full inverted index（**详细倒排索引**），表现为{单词，(单词所在文档ID, 文档中的位置)}

**全文检索表**

![img](https://pic4.zhimg.com/80/v2-ce1ac39b76055801c07f68a5239e958f_720w.jpg)

**inverted file index（倒排文件索引）-辅助表存储为**

倒排文件索引类型的辅助表存储为：

![img](https://pic3.zhimg.com/80/v2-f1e3c8485eb56fbf60f5001ca45869d6_720w.jpg)

**full inverted index（ 详细倒排索引）-辅助表存储为**

详细倒排索引类型的辅助表存储为，占用更多空间，也更好的定位数据，比提供更多的搜索特性：

![img](https://pic2.zhimg.com/80/v2-3e4e1bf9b501bf98d3862299ee721431_720w.jpg)

**全文检索索引缓存**

辅助表是存在与磁盘上的持久化的表，由于磁盘I/O比较慢，因此提供FTS Index Cache（全文检索索引缓存）来提高性能。FTS Index Cache是一个红黑树结构，根据（word,  list）排序，在有数据插入时，索引先更新到缓存中，而后InnoDB存储引擎会批量进行更新到辅助表中。

当数据库宕机时，尚未落盘的索引缓存数据会自动读取并存储，配置参数innodb_ft_cache_size控制缓存的大小，默认为32M，提高该值，可以提高全文检索的性能，但在故障时，需要更久的时间恢复。

在删除数据时，InnoDB不会删除索引数据，而是保存在DELETED辅助表中，因此一段时间后，索引会变得非常大，可以通过optimize  table命令手动删除无效索引记录。如果需要删除的内容非常多，会影响应用程序的可用性，参数innodb_ft_num_word_optimize控制每次删除的分词数量，默认为2000，用户可以调整该参数来控制删除幅度。

**全文索引的一些限制**

1、现在只支持myisam和innodb
2、不支持分区表
3、多列组合的全文检索索引必须使用相同的字符集和字符序
4、象形文字不支持。需要ngram来分词
5、建立全文索引的各个字段必须统一
6、match（）里的查找列，必须是在fulltext索引里定义过的
7、against（）必须为字符串且为常量
8、索引提示会更差
9、在innodb中，所有涉及到全文索引列的DML操作（update，insert，delete），只会在事务提交的时候，执行。中间可能要分词，标记等
10、不能用 % 通配符
11、不支持没有单词界定符`（delimiter）`的语言，如中文、日语、韩语等

## 9.为什么采用B+ 树？这和Hash索引比较起来有什么优缺点吗？

为什么采用B+ 树？

* 磁盘IO读写次数
* 每次查询的时间复杂度是固定的
* 遍历效率更高

优缺点

* 哈希索引适合等值查询，但是无法进行范围查询 

* 哈希索引没办法利用索引完成排序 

* 哈希索引不支持多列联合索引的最左匹配规则 

* 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

## 10、讲一下b+树的结构

B+树和二叉树、平衡二叉树一样都是经典的数据结构。

　　B+树由B树和索引顺序访问方法（ISAM，这就是MyISAM引擎最初参考的数据结构）演化而来，实际中已经没有使用B树的情况了。

　　B+树是为磁盘或其他直接存储辅助设备设计的一种平衡查找时。

　　B+树中，**所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上**，由各叶子节点指针进行连接。

　　如下：其高度为2，每页存放4条记录，扇出（fan out）为5。所有记录都在叶子节点上，并且是顺序存放的。

![img](https://img2018.cnblogs.com/blog/1007094/201907/1007094-20190714214607088-2001103733.png)

 