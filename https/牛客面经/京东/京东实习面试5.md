## 1.问了一下[项目

## 2.HashMap底层实现，扩容阈值，具体怎么扩容，扩容优化，抖动函数，集合大小为什么是2的幂，为什么阈 值是8（[源码]()里是8-1），jkd1.7,1.8具体优化的地方。
hashmap底层由数组加链表实现，数组中每个位置相当于一个桶，可以不断的往里面存放数据，这些数据以链表的方式存在。

扩容阈值：8

扩容：由两种情况会发生扩容，一是在数组长度小于64，并且链表长度大于8，就会产生扩容，二是当前个数大于等于阈值，并且要存的位置已经有元素，就会扩大2倍。

具体扩容：创建一个新数组容量为原来的两倍，1.7是直接重新计算位置hashcode &(n - 1)，

1.8中，注意到扩容两倍之后就是长度减一的二进制多了一位，在计算时，hashcode和当前（n-1）多出的那一位相与为1，就用原索引加当前扩容的大小，相与为0，维持原索引。

扰动函数：扰动函数优化了，1.7时使用了4次扰动，1.8只用了一次，为什么1.8的效果反倒比1.7更好呢，因为1.8的扰动是将高位和低位相与，相当于融合了高位和低位的数字特征，在经过扰动之后，散列效果会更好。（有实验证明）

集合大小为什么是2的次幂：扩容时根据hashcode & (n - 1)计算下标，其中n是数组的长度，当n为2的次幂时，n - 1的二进制都是由1组成。这时&操作相当于取余操作，两者的结果都是一样的。这就提高了效率。

优化：1.将数组加链表中的链表改为数组加链表/红黑树。因为在某些极端的情况下，1.7中的链表会产生很长的一根链表，其查询效率接近O(n)，在1.8中，将链表长度超过8的转换为红黑树，这样的查询效率会降到O(logn)。

2.在resize过程中，1.7使用四次扰动函数，再计算索引值，1.8只扰动一次，这样提高了效率。并且1.8中的扰动函数结合了hashcode高位和低位的数字特征，具有更好的散列性。

3.hashmap1.7使用头插法插入节点，会造成内存泄漏，1.8使用尾插法，没有内存泄漏问题。

## 3.线程安全集合，ConcurrentHashMap,具体实现，jdk1.7,jkd1.8区别，分段锁，锁粒度，好像答的不够多，然后又挤出来一个计数方法，1.8计数特别麻烦。 

concurrenthashmap在1.7中使用segment+hashentry的结构，其中hashentry使用数组加链表的结构。

在1.8中使用hashentry结构，其中hashentry使用数组+链表/红黑树结构。

在1.7中concurrenthashmap可以对每个segment进行加锁操作，并且是使用synchronized进行加锁。

1.8中使用的是CAS+synchronized加锁。对每个hashentry数组中的位置都可以加锁。



## 4.多线程相关，volatile原理，JMM，synchronize优化（还讲了对象头markword 和类元指针），reentrantlock原理，AQS。 

并发编程由以下3大重要特性：

原子性：保证每个操作要么都成功执行，要么都执行失败。

可见性：保证对每个数据的修改都会立刻被其他的线程看到。

有序性：程序按照代码的先后顺序执行。在JVM中，为了执行效率，有可能会发生指令重排的现象。也就是会发生将程序的不相关操作乱序执行。在单线程中，这样是没有问题的，但是在多线程中，可能产生很严重的问题。



volatile可以保证有序性和可见性，无法保证原子性。

volatile的可见性：

- 当对volatile变量执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存
- 写操作会导致其他线程中的缓存无效

这样，其他线程使用缓存时，发现本地工作内存中此变量无效，便从主内存中获取，这样获取到的变量便是最新的值，实现了线程的可见性。

volatile的有序性：

volatile在读写前后都加上了内存屏障，在一定程度上保证了有序性。

JMM：线程独有的区域由：程序计数器、本地方法栈、虚拟机栈。共有的区域有：方法区、堆内存、直接内存。

锁优化：无锁、偏向锁、轻量级锁、重量级锁。随着对资源的竞争激烈程度，进行锁升级。

在synchronized里面，起关键性作用的是对象头和monitor。synchronized通过monitorenter获取锁，通过monitorexit释放锁。

一个对象包括对象头、实例数据和对齐填充。

对象头中分为两部分：markword和klass pointer。markword中存储了对象运行时的状态。

markword是随着运行状态而变化的。

reentrantlock原理：reentrantlock是一个可重入锁，指的是同一线程外层函数获得锁后,再进入该线程的内层方法会自动获取锁。底层是使用CAS+AQS，AQS是AbsractQueuedSynchronized的缩写，是一个队列，是一个FIFO队列，维护想要访问的共享资源的线程队列。CAS是compare and swap的简写，通过调用底层的unsafe类中的compareandset方法进行锁的获取。compareandset方法是对对象的state字段进行检查，如果当前state为0，说明资源没有被上锁，可以使用，如果不为0，则表示已经被上锁。

reentrantlock默认使用非公平锁，也就是线程可以抢夺共享资源的访问权，如果使用公平锁，如果当前资源被上锁，当前线程进入AQS队列，排队等待锁释放，对头节点是正在访问资源的线程，如果释放锁，下个资源就可以获取到锁，并且移除对头节点。



## 5.final修饰类 方法 属性区别。 

final修饰类：表示该类不可以被继承

final修饰方法：表示该方法不可以被重写。

final修饰属性：表示该属性一经初始化就不可以被修改，对于基本变量来说是其值不能修改，对于引用变量来说是其引用不可以再修改。

## 6.JVM内存布局，虚拟机栈本地方法栈，栈帧里的结构，哪些区域线程私有公有。 
![img](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png)

![img](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/Java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9FJDK1.8.png)

本地方法栈的栈帧：局部变量表、操作数栈、动态链接、出口信息。

公有区域：堆，方法区（元空间）。

私有区域：虚拟机栈、本地方法栈、程序计数器。

## 7.堆区域的划分，垃圾回收算法，标记算法，内存分配算法（和垃圾回收器相关）。

在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

1. 新生代内存(Young Generation)
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

[![JVM堆内存结构-JDK7](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png)](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM堆内存结构-JDK7.png)

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

[![JVM堆内存结构-JDK8](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png)](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/pictures/java内存区域/JVM堆内存结构-jdk8.png)

**上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。**

![垃圾收集算法分类](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.png)

![垃圾收集器分类](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/jvm/pictures/jvm%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png)

标记算法有：引用计数法、可达性分析法。

引用计数法是为每一个对象分配一个计数器，每当有其他对象引用它，计数器加一。当计数器为0时，表示当前对象没有任何引用，可以被GC了。这个方法简单高效，但是没办法解决循环引用问题。

可达性分析法：将一系列GC root当作根节点，向下根据引用关系寻找可达对象，寻找过程叫做引用链，一个系统可以有多个根节点。如果一个对象无法通过任何的GC root搜索到，则被认为没有任何引用，可以被GC。可达性分析算法必须处于一致性快照中，也就是STW（Stop the word）,因为如果同时有对象的引用被更改，可达性分析算法就不准确了。

**内存分配算法**

Java堆是被所有线程共享的一块内存区域，主要用于存放对象实例，为对象分配内存就是把一块大小确定的内存从堆内存中划分出来，通常有指针碰撞和空闲列表两种实现方式。

**1.指针碰撞法**
假设Java堆中内存时完整的，已分配的内存和空闲内存分别在不同的一侧，通过一个指针作为分界点，需要分配内存时，仅仅需要把指针往空闲的一端移动与对象大小相等的距离。使用的GC收集器：Serial、ParNew，适用堆内存规整（即没有内存碎片）的情况下。

**2.空闲列表法**
事实上，Java堆的内存并不是完整的，已分配的内存和空闲内存相互交错，JVM通过维护一个列表，记录可用的内存块信息，当分配操作发生时，从列表中找到一个足够大的内存块分配给对象实例，并更新列表上的记录。使用的GC收集器：CMS，适用堆内存不规整的情况下。

## 8.还问了[项目]()中使用了什么垃圾回收器，serial serial old。
## 9.方法区，元空间。 具体怎么优化解决STW问题。 

元空间与永久代最大的区别在于：元空间不在虚拟机内存中，而是使用本地内存。

**永久代为什么要被元空间替换**
随着java8的到来，hotspot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）。
由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。
这项改动是很有必要的，原因有：

* 为永久代设置空间大小是很难确定的。

* 在某些场景下，如果动态加载类过多，容易产生Perm 区的OOM。比如某个时间的Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误：
  java.lang.OutOfMemoryError:PermGen space
  而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存，因此，默认情况下，元空间的大小仅受本地内存限制

* 对永久代进行调优是很困难的。
  full GC 严重影响性能。

* 放在本地内存不会影响Jvm在运行时的性能，因为都是放在本地内存中，而不是放在本地磁盘上。

  **怎么优化解决STW问题**

  首先看一下日志 是因为啥发生的吧 如果minor gc过多 就调整新生代大小 full gc过多就调整老年代大小

## 10.对象的所有过程，创建销毁，加载链接初始化，分配内存CAS（还讲了TLAB参数），具体怎么移动到老年代（15），还讲了具体操作数栈中的过程，内存泄漏。 

对象的从new关键字开始被创建，在new的过程中，首先在常量池中查找是否可以定位到一个符号引用的类，查看这个类是否经过了加载连接初始化，如果不存在类对象，则开始执行类加载过程。

类加载过程:加载 > 连接 > 初始化。其中连接又分为三部分：验证 > 准备 > 解析。

加载的过程就是将class文件从各个来源通过类加载器加载到内存中。

验证：对文件格式的验证：验证文件格式是否符合规范

​			验证元数据，对字节流进行语义分析，判断是否符合java语言规范。

​			字节码验证：确认程序的语义是合法的，合乎逻辑的

​			符号引用验证：确认可以根据符号引用找到相对应的匹配。

准备：在堆内存中的Eden区为类变量分配内存，并赋予java默认的初始值。这里的内存分配算法有指针碰撞法，空闲列表法，碰撞指针法：假设java内存是规整的，指针在已使用内存和未使用内存的分界处，每当需要分配内存时，就将指针移动所需要的大小，使用的GC器有serial，pernew等内存规整的情况。空闲列表法：记录每一块空闲的内存，当需要内存分配就在列表中拿出一块进行分配，使用的GC器有CMS，适合内存不规整的情况。

内存分配中带来的线程不安全问题，在并发环境下即使修改的只是一个指针，也会引起线程不安全问题。有两种解决方法，一种是对操作进行同步处理，实际上虚拟机使用CAS+失败重试方式保证线程安全。二是在堆中为每个线程提前分配一个TLAB（本地线程分配缓存），哪个内存需要进行缓存时，就在自己线程的TLAB上进行分配，只有在分配TLAB时才需要同步锁定，虚拟机中使用-XX：+/-UseTLAB命令开启。

解析：将符号引用转化成直接引用。

初始化：在这个阶段，会根据程序员的主观的设计，对变量进行初始化赋值。

对象在使用过程中，第一次从Eden区经过新生代垃圾回收机制还有没被回收，则进入Survivor区中的s0或者s1区（大对象直接进入老年代），如果又经过一次GC，没有被回收则年龄+1，当年龄到达一定大小（默认为15），就晋升到老年代。

操作数栈是一个在做运算的时候临时的内存区域，将局部变量表中的元素，加载到操作数栈中，进行运算，结束后写回到局部变量表。

## 11.CMS 和 G1相关也讲了一下。 

CMS：concurrent mark sweep，注重用户体验的垃圾回收器。

主要分成四个阶段：初始标记 > 并发标记 > 重新标记 > 并发清理

初始标记：首次对垃圾进行标记，是很短暂的，记录下直接与GC ROOT 相连的对象。

并发标记：应用程序线程和GC线程同时运行，用一个闭包结构记录可达对象。

重新标记：因为上一阶段是并发执行的，这一阶段就是对上一阶段中有引用修改的进行修正。这一阶段比并发标记长。

并发清理：这一阶段是应用程序和GC线程同时运行，将标记的垃圾进行清理。

优点是：并发执行，低停顿。

缺点：对CPU资源敏感，无法处理浮动垃圾，使用标记-清除算法，会产生大量垃圾碎片。

G1：Garbage first，面向服务器的垃圾回收器。G1将整个堆分成了大小相同的内存块，每个块可以是Eden，也可以是Survivor，也可以是old。在回收前后会自动变化。

具有一下优势：

并发并行：充分利用多核多线程的优势，来缩短STW时间，

分代收集：G1不需要与其他的垃圾回收器配合就可以自己管理整个堆，但还是保留了分代的概念。

空间整合：从整体来看是标记整理，从部分来看是标记-复制。

可预测的停顿：可以指定什么时候进行STW。

分为以下几个步骤:初始标记 > 并发标记 > 最终标记 > 筛选回收。

G1在后台维护了一个优先列表，每次根据允许的收集时间，选择最有回收价值的区域进行回收。 

## 12.ThreadLocal原理，里面的map具体怎么实现的，和hashmap的不同，内存泄漏问题，具体应用场景。 

每个线程维护一个threadlocalmap，threadlocal本身并不存储数据，只是一个用来存取数据的工具类。

其中的map类似hashmap，是一个数组链表结构，其中key存储threadlocal的弱引用，value存放具体的信息。

具体可以看下图：

![img](https://pic2.zhimg.com/80/v2-aaba364d9af11719667ffc9ab6b64dad_720w.jpg)

与hashmap的区别：

1.hashmap中的key可以存储任意的对象，threadlocalmap中的key可以存储threadlocal的弱引用。

2.hashmap的hashcode计算方法和threadlocalmap不一样。

3.hashmap中冲突解决使用的是链地址法，threadlocalmap使用开放地址法。

内存泄漏问题：当弱引用的对象的强引用存在时，弱引用不会被GC。当强引用被GC，key就会被置为null，这样的entry永远不会被GC。这就会造成内存泄漏问题。

内存泄漏的两个必要条件：1.threadlocal的强引用已经断开。2.当前线程并未结束。

源码中已经考虑到这个问题，在每次调用set/get方法都会对key为null的entry进行清理。但是这并不能解决问题，在使用中，最好在用完之后进行remove操作。

应用场景：在框架中，使用threadlocal进行数据库连接，保证线程的每次都可以连接同一个数据库。

或者是解决simpledataformat类的线程安全问题。

## 13.MySQL索引相关，聚簇索引。 

mysql的innodb引擎默认使用B+树索引，还可以选择hash索引。B+树索引是将主键作为索引，数据存放在叶子节点中。因此innodb表数据本身就是主索引，这被称为聚簇索引。在使用主索引时，找到key就找到了数据，使用辅助索引则需要先找到key，取出值，之后根据值走一遍主索引，拿到数据。

聚簇索引是：将索引和数据放到一起，找到索引就找到了数据。

非聚簇索引：将索引和数据分开放，找到索引就可以找到key，根据key值再去找数据。

## 14.innodb和myisam的区别。 

区别：

* innodb支持事务，myisam不支持事务
* innodb支持外键，myisam不支持外键
* innodb支持行级锁，myisam只支持表级锁，这也是为什么mysql5.5之后使用innodb的原因
* innodb是聚簇索引，myisam是非聚簇索引，聚簇索引：将索引和数据放在一起，找到索引就找到了数据。  非聚簇索引：索引和数据分离，需要通过索引得到key，再通过key找到数据。

myisam在数据库崩溃之后，恢复比innodb更难。

在读频繁的系统中myisam表现更好，读写都有的环境使用innodb更好。

## 15.四个隔离级别，每个级别分别解决了什么问题，讲了默认隔离级别和常用隔离级别。 
读取未提交：允许读取还未来得及写入内存的数据，可能产生脏读、幻读、不可重复读。（写操作加行级共享锁，读操作不加锁）

读取已提交：不允许读取还未来的级写入内存的数据，可能产生幻读、不可重复读。（读取加行级共享锁，写操作加行级排他锁，读写完毕就释放）

可重复读：在事务执行过程中，多次读取同一数据，值不变，可能产生幻读。（读写都加锁，直到事务执行完毕）

可串行化：让事务完全隔离开执行，也就是一个事务执行完另一个事务开始执行。（加表级锁）

默认隔离级别是：mysql的innodb默认是可重复读。

## 16.gap lock, record lock ,next key lock。 

- Record lock：单个行记录上的锁，对索引项加锁，锁定记录本身
- Gap lock：间隙锁，锁定一个范围，不包括记录本身，对索引项的间隙加锁，比如对第一行和第二行间隙，和倒数第二行和最后一行的间隙加锁，锁定的是从第二行到倒数第二行的记录。这样就防止了幻读。
- Next-key lock：record+gap 锁定一个范围，包含记录本身

## 17.MVCC怎么实现的，解决了什么问题，undolog讲了一点。 

mvcc在每行加了两个隐藏列，一个是当前版本号，一个是过期时间，用来控制事务的隔离。

每当一个事务访问数据库的时候，版本号都会自动递增。

在使用select的时候只能读取到版本号小于自身的数据。

insert时将当前版本号作为行版本号。

delete时为每个删除的行保存当前的行版本号。

update时将当前版本号作为行版本号，并将当前版本号保存到原来的行记录中，作为删除标识。

事务的隔离性就是通过mvcc和锁保证的。

## 18.B+树讲了一点。 

B+树是由B树和索引顺序访问法演变而来，数据都存放在B+树的叶子节点中，叶子节点通过指针相互连接。

B+树是为磁盘或者其他辅助存储设备设计的平衡查找树。

## 19.脏读 幻读，讲一下幻读场景。 

脏读：在还未来的及将数据写入数据库时，有新的事务对当前数据进行了读取，造成了读取的数据和数据库中数据不一致的情况。

幻读：事务T1读取到了一些数据，之后事务T2对这些数据进行了插入或者删除，事务T1再次读取时，会发现多了或者少了一些数据的幻觉。



## 20.redis持久化，讲了aof rdb，具体场景，两者一起用，cow和fork，aof瘦身。

redis的持久化分为两种模式：AOF和RDB

AOF：将每次的写操作都记录到AOF文件中，在按照规定的时间批量的写入数据库。存储速度快，资源消耗的少，但是恢复比较慢。占用的空间比较大。

RDB：每次按照规定时间生成一个快照（这个快照只是内存中被修改的数据），之后将这个快照存入数据库。存储速度慢，恢复速度快，占用空间小，资源消耗的多。

在redis4.0之后对持久化机制进行了优化，即结合使用aof和rdb，先生成rdb以二进制格式放到aof文件中，在重写操作执行之后的操作，都会以aof的方式追加到aof文件末尾。

aof文件是比rdb文件更大的，所以当aof文件增大到一定程度之后，就会执行rewirte操作，aof重写就是读取redis中的数据，转化为写命令，同步到aof文件中的过程，也就是将对同一个数据的多条命令执行结果转化为最终数据所对应的指令执行记录。

cow是Copy on write，就是写时拷贝。fork一个子进程，只有在父进程发生写操作修改内存数据时，才会真正去分配内存空间，并复制内存数据，而且也只是复制被修改的内存页中的数据，并不是全部内存数据；

## 21.缓存雪崩 缓存穿透（好像和击穿弄混了），布隆过滤器。 

**缓存穿透：大量不存在缓存的key的请求，黑客的恶意攻击。**

**缓存击穿：针对同一个key大量的访问请求，当这个key失效时，依然有这么多的请求量，导致在失效的一瞬间，所有的请求都达到数据库上，导致数据库宕机。**

**缓存雪崩：redis中的key同时大规模的失效。大量访问直接打到数据库中。**

布隆过滤器：布隆过滤器由一个二进制向量（位图）和几个hash函数组成，当一个key不存在于缓存中，在数据库查到他的信息，可以添加到缓存中，并且将key经过几个哈希函数，映射到不同的位上，将位值改为1。表明当这几个位上的数值都为1时，表明这个值存在，也就是key存在于缓存中。

当一个请求到达，先经过布隆过滤器查找是否存在一个这样的key，当存在才放行。

## 22.redis  zset，跳跃表，为什么不用[红黑树]()，跳跃表实现讲了一下。

zset 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表，底层使用跳跃链表实现。

跳跃链表是一种平衡结构，选择出几个节点作为索引，比索引大的都在后面，如图所示

![img](https://pic1.zhimg.com/80/v2-066a9c3461235fc1badd19c534e08b7c_720w.jpg)

redis给出的官方解释是：跳跃表的实现比红黑树的实现简单，并且性能相近。

## 23.分布式锁。答了incr,set,setnx，redlock。 

setnx：当key不存在时，才可以进行set，在并发环境下会出现问题，可能产生，在失效时间过后，当前线程依然要使用这个资源的情况，或者已经被的线程使用，但是当前线程依然在使用，或者当前线程崩溃，这个资源就永远拿不到了。

![88de3f98e74e21892f519182d8c752ee.png](https://img-blog.csdnimg.cn/img_convert/88de3f98e74e21892f519182d8c752ee.png)

redlock：红锁算法认为，只要N /2  + 1个节点加锁成功，那么就认为获取了锁， 解锁时将所有实例解锁。 流程为：

1. 顺序向五个节点请求加锁
2. 根据一定的**超时时间**来推断是不是跳过该节点
3. 三个节点加锁成功并且花费时间小于锁的有效期
4. 认定加锁成功

也就是说，假设锁**30秒**过期，三个节点加锁花了31秒，自然是加锁失败了。

这只是举个例子，实际上并不应该等每个节点那么长时间，就像官网所说的那样，假设有效期是10**秒**，那么单个redis实例操作超时时间，应该在5到50**毫秒**(注意时间单位)

还是假设我们设置有效期是30秒，图中超时了两个redis节点。 那么加锁成功的节点**总共花费**了3秒，所以锁的**实际有效期**是小于27秒的。

即扣除加锁成功三个实例的3秒，还要扣除等待超时redis实例的总共时间。



redisson：Redisson是**java的redis客户端之一**，提供了一些api方便操作redis。源码中**加锁/释放锁**操作都是用**lua**脚本完成的

![https://img3.sycdn.imooc.com/5cad94bc0001940310580525.jpg](https://img3.sycdn.imooc.com/5cad94bc0001940310580525.jpg)



## 24.分布式事务（不会） 

https://zhuanlan.zhihu.com/p/183753774

## 25.zoo[keep]()er（不会）

## 26.dubbo springcloud(说以前写过Demo现在不记得了)。 
## 27.[redis]()集群相关，讲了哨兵，主从，集群，选举Leader，掉线了会发生什么，脑裂，hash一致性算法（讲了虚拟结点），哨兵之间订阅沟通还有一些不记得了。
哨兵模式：用来监督主库是否已经宕机，宕机后可以通过哨兵模式选举性的leader。

如何判断主库已经宕机？当一个哨兵ping主库超时，就主观认为主库已经宕机，当哨兵集群中有n/2+1的哨兵认为主库已经宕机，则客观认为主库宕机。

主从复制：redis集群大部分采用读写分离，这样只有主库可以进行写操作，从库只能进行读操作，在一定时间后按照一定的规则，主库会将更新的数据更新到从库，这样就保证了数据副本的一致性。

主从复制的方案有两种：1.全量复制，将主库中的数据全部复制到从库中。2.增量复制，将最近新修改的复制到从库中。一般在集群刚启动，或者从库中没数据时，先启用全量复制，之后使用增量复制。

哨兵之间的通信是通过redis的发布订阅功能实现的。主库维护一个通信频道，哨兵之间可以通过这个频道进行通信。

选举leader：当主库宕机，则从从库中按照规则选举新的leader。

选举规则如下：从库的在线状态，从库的离线次数，从库与旧主库的接近程度，从库优先级，从库ID号小的得分高。

主从异步复制：当主库发生故障，还未来得及将更新的数据更新到从库中，哨兵检测到这个故障，就会发起选举新的leader，未来得及更新的数据就会被丢弃。

脑裂：当主库还未来得及将更新的数据更新到从库中，因为网络故障，导致哨兵认为主库掉线，之后哨兵集群进行选举产生新的leader，在主库恢复之后，未来得及更新的数据就会被丢弃，导致脑裂。

hash一致性：将每个库的IP或者编号当作输入，得出一系列输出值，映射到环形区域，对于用户数据进行相同的操作。然后让用户数据映射的值沿着顺时针的方向移动，遇到的第一个服务器就是给他分配的服务器。

![img](https://pic3.zhimg.com/80/v2-0fb33fe30c7a05eee2abe3784a42f98a_720w.jpg)

## 28.AOP原理，IOC原理。循环依赖。CGLIB,JDK proxy，讲了底层缓存，之间的区别。 

  IOC:IOC是一种软件设计思想，将原来程序中创建对象的控制权交给Spring框架来管理。IOC在别的框架中也有使用，并非是spring独有的。IOC实际上就是一个map（key，value）map中存放的是各种对象。

将对象之间的依赖关系交给ioc容器来管理，并由框架完成对象的注入，大大简化了应用开发，把应用从复杂的依赖关系中解放出来。IOC容器就像一个工厂一样，当我们需要对象的时候，只需要配置好配置文件/注解，完全不用考虑对象是如何生成的。在实际项目中，一个service有成百上千个类，如果要实例化这个service，可能需要搞清楚这个service所有底层类的构造函数。现在使用IOC，只需要配置好，然后在需要的地方引用就可以了。

AOP：面向切面编程，将与业务无关的，却被业务模块所共同调用的逻辑或功能封装起来，以减少重复的代码，降低程序间的耦合，并且有利于程序的可扩展性和可维护性。

Spring AOP是基于动态代理的，如果一个类实现了某个接口，就可以可以使用JDK Proxy代理对象，对于没有实现某个接口的类，会使用CGlib去创建这个类的子类，完成对这个类的代理。

当然也可以使用Aspect J进行代理，Aspect J是Java生态圈中最完整的AOP框架。AspectJ 是编译时增强的，Spring aop是运行时增强的。 

循环依赖：循环依赖是指在ioc容器中创建对象时，对象A依赖对象B，对象B依赖对象A，而A,B两个对象都没有实例化出来，在实例化的时候会产生错误。在spring中，使用构造方法完成依赖注入是不支持循环依赖的。使用set方法执行是支持循环依赖的。在创建A过程中发现依赖于B对象，就去调用getbean方法获取B的bean，如果当前的容器中没有B的bean就去创建B的bean，在创建B的bean的过程中，发现依赖于A，此时如果开启支持循环依赖，就会去一级缓存中找A，如果找不到就去二级缓存中找，找不到再去三级缓存中找，因为A已经被实例化，只是没有经过初始化赋值操作，所以会被暴露在三级缓存中，我们可以从三级缓存中拿到A的bean，A就进入了二级缓存，B就继续完成创建，之后返回给A，A完成创建。

CGlib：是一种完成代理的方式，在编译时通过修改字节码完成功能增强，可以应用于实现了接口的类，也可以应用于没有实现接口的类。对于实现接口的类，可以在spring中进行设置，强制其使用CGlib方式进行代理。这个方法是通过生成一个该类的子类的方式完成代理。

JDK proxy：只能作用于实现了接口的类，通过实现接口的方式对该类进行增强。具体的示意如下：

![SpringAOPProcess](https://camo.githubusercontent.com/2948f9b2b5c45eb208990afcac1bf5638783dc3ebc834d3d7d2d4f7cc050981c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f537072696e67414f5050726f636573732e6a7067)



其他：个人优势，[项目]()相关。 