## 在浏览器里输入url后整个过程 

![url输入到展示出来的过程](G:\王鹏\面试\https\牛客面经\京东\images\url输入到展示出来的过程.jpg)

OSPF：最短路径寻址协议。

1.从缓存中找域名的IP，找不到就去DNS中找。

2.浏览器发送请求，建立连接

3.服务器处理请求

4.服务器返回HTML

5.浏览器渲染HTML

6.连接结束

## Dns协议在哪一层，tcp在哪一层，tcp如何保证传输顺序，滑动窗口协议 

DNS协议在应用层，TCP在运输层，

tcp对每个数据包分配一个编号，并且在特定时间内，需要接收方返回收到这个包的确认信息。

如果在一定时间内，没有收到确认信息，就会进行重新发送，直到达到最大次数。

如果接收方收到，首先进行检验数据包是否有误，如果正确，转交给上层。

滑动窗口协议：分为发送端窗口和接收端窗口，发送数据的大小取两者的最小值，发送端发送数据给接收端，接收端收到数据返回确认帧，告诉发送端，接下来要发送哪个帧。这个窗口的大小是动态变化的，比如当发送端或者接收端的缓存区域不够，就会适当的缩减窗口的大小。

## Tcp和udp区别 

tcp是可靠传输，udp是不可靠传输

tcp速度慢，udp速度快

tcp传输使用的资源多，udp使用的资源少

tcp头部是20-60字节，udp是8字节

tcp需要建立连接，udp不需要建立连接

tcp只能一对一，udp可以一对多

## 面向对象的特性，怎么理解多态？ 

封装，继承，多态是面向对象的三大特性

多态：表示一个对象具有的多种状态，具体表现为父类引用指向子类实例。

有以下特点：

* 引用类型和对象类型之间存在实现/继承的关系。
* 引用类型具体调用哪个类中的方法，只有在程序运行期间才能确定。
* 不能调用父类中没有，子类中有的方法
* 如果子类实现了父类的方法，则调用子类的方法，如果没有实现，则调用父类的方法

继承：

子类可以继承父类，就是可以在父类的基础上，快速的创建类，提高代码的可用性，程序的可维护性。

* 子类拥有父类的所有属性和方法，但是不能使用父类的私有属性和方法
* 子类可以拥有自己的属性和方法，即子类可对父类进行拓展
* 子类可以按照自己的方式实现父类的方法

封装：可以不让外界访问方法中的变量，而是提供一种方法，外界可以通过这个方法，控制方法内的属性。

## 重写和重载的区别 

重写是指当子类继承自父类的相同方法，想要做出和父类不同的响应，就要覆盖父类的方法。

重载是指拥有相同方法名，可以根据输入参数的不同，做不同的处理。

## Arraylist和linkedlist的区别？ 

arraylist底层是动态数组，linkedlist底层是双向链表

arraylist需要经过扩容，linkedlist不需要扩容

arraylist支持随机访问，linkedlist不支持随机访问

arraylist的空间浪费在需要留空给将来插入的数组，linkedlist的空间浪费在前后指针

arraylist查找效率高，linkedlist是在链表头尾插入删除操作效率高，指定位置效率都不高

## mYbatis的sql注入 

mybatis使用#{}防止sql注入，使用${}不能防止sql注入，

#{}是调用JDBC的PreparedStatement进行预编译，sql注入只在编译过程中起作用

${}是直接进行字符串拼接，会引起SQL注入

## Mysql的索引的作用？Innodb和myisam的区别？有哪几种行锁？ 

是数据库性能调优技术的基础，常用于实现数据的快速检索。

innodb和myisam的区别：

* innodb的主索引是聚簇索引，mysiam是非聚簇索引
* innodb支持事务，myisam不支持事务
* innodb没有保存具体行数，myisam保存了具体行数
* innodb支持外键，myisam不支持外键
* innodb最小的锁粒度是行级锁，myisam最小是表级锁。
* innodb支持MVCC（多版本并发控制协议），myisam不支持

行锁有三种：

* record lock：记录锁，表示锁定这个记录
* gap lock：间隙锁，表示锁住一个范围，但不包括边界，例如，在第二行和第三行之间加锁，在最后一行和倒数第二行之间加锁，锁住的是第三行到倒数第二行之间的数据，不包括第二行和岛主第一行。
* next-key lock：是上面两种锁的结合，包括边界也包括范围内



## 快排的时间复杂度 

平均时间复杂度O(nlogn)

最坏情况时间复杂度O(n*n)

![1342700879_2982](G:\王鹏\面试\https\牛客面经\京东\images\1342700879_2982.jpg)

## 抽象类和接口的区别，接口里允许有私有方法吗？ 

* 抽象类中可以有构造方法，接口中不能有
* 抽象类中可以有protected方法，接口中不能有
* 抽象类中可以有具体方法实现，接口中不能有
* 抽象类中可以有静态方法，接口中不能有
* 一个类可以实现多个接口，但是只能继承一个抽象类

抽象类是为了代码的复用，接口是为了规定类必须有什么

java8中接口中不能有私有方法，java9中允许有私有方法和私有静态方法

## Redis的数据类型和持久化方式？知道resp协议吗？ 

![image-20210326165049400](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20210326165049400.png)

String（字符串）：动态字符串，可以修改，存储K-V键值对，当<1M，加倍扩容，>1M时，每次+1M

 list（列表） ：ziplist/快速链表，连续内存空间，存有offset偏移量，方便快速定位最后一个元素，为了支持双向遍历。可以实现消息队列，最新列表等

hash（字典） ：数组+链表，value只能存储string，购物车，存储对象等

set（集合） ：元素是无序，唯一的，好友、粉丝、关注的集合，可以作集合运算，比如共同好友

zset（有序集合）：跳跃链表，每个value可以有一个score，比如，value是学生ID，score是成绩，可以按照成绩进行排序

持久化方式有AOF,RDB

AOF是以日志方式进行持久化，RDB是以快照方式进行持久化

每个写操作都会记录到AOF的日志中，经过一定的时间，会统一持久化到数据库中

RDB是经过规定时间，将内存中的数据以快照的方式持久化到数据库中。

redis4.0之后允许混合持久化，就是在快照之后的数据更改，都是用AOF方式追加到AOF文件中，首先将RDB文件以AOF方式写入到AOF文件中，后来的操作追加到AOF文件中。

resp协议是客户端和redis服务器之间的通讯协议，是在tcp协议之上的一个协议，用来规定客户端和redis服务器之间传输消息的一种协议格式。

- 单行回复（单行字符串回复），回复的第一个字节将是“+”
- 错误消息（单行字符串回复的另外展示形式），回复的第一个字节将是“-”
- 整型回复（正整形数字回复），回复的第一个字节将是“:”
- 批量回复（多行字符串回复），回复的第一个字节将是“$”
- 多个批量回复（数组回复），回复的第一个字节将是“*”

例如

```text
> set name leeprince
+OK\r\n  # 服务端实际返回   \r\n表示换行
---
OK # redis-cli 客户端显示
```



## 用[redis]()实现分布式锁 

setnx+setex：存在设置超时时间失败的情况，导致死锁

set(key,value,nx,px):将setnx+setex变成原子操作

问题：

* 任务超时，锁自动释放，导致并发问题，使用redisson解决（看门狗监听，自动续期）
* 以及加锁和释放锁不是同一个线程的问题，在value中存入uuid（线程唯一标识），删除锁时判断是不是自己的锁（使用lua保证原子性）
* 不可重入，使用redisson解决（实现机制类似AQS，计数，每一次setnx都会加一）
* 异步复制可能造成锁的丢失，使用redlock解决（redisson中也有redlock的实现）
  * 顺序向n个节点请求加锁
  * 根据一定的超时时间推断是不是跳过该节点
  * 有n/2 + 1的节点加锁成功并且花费时间小于锁的有效期
  * 认定加锁成功

## Hashmap是线程安全的吗？为什么不安全？ 

不是线程安全的，hashmap没有锁机制保护，比如在进行插入操作得时候，两个线程同时发现对应位置是空的，都会进行插入操作，这时第二个插入的就会覆盖掉第一个插入的数据，导致线程不安全。

## 讲一下AOP 

AOP：面向切面编程，是spring得一个特性。是将与业务无关却又被业务所调用的模块封装起来，减少代码的重复。降低程序间的耦合，提高代码的复用性，有利于代码的可扩展性和可维护性。

springAOP是基于动态代理的，使用JDK的proxy进行代理，如果类实现了某接口，则可以通过实现接口的方式进行对类的增强。

## 乐观锁和悲观锁，讲一讲CAS。 

悲观锁：每次拿数据都要认为别人会修改，所以先进行加锁，再拿数据。

乐观锁：每次拿数据都认为别人不会修改，所以不加锁，直接拿数据。

乐观锁是通过cas实现的，多个线程尝试同时更新一个数据，只有一个线程可以成功得到这个数据，其他线程都会被挂起。

cas：compare and swap，底层通过调用unsafe类中的compareandset来实现，意思是比较并交换，这个方法存在三个操作数，内存位置，期望值，更新值。如果内存中值为期望值，则直接更新，否则不做任何操作。