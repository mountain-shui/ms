1.自我介绍

## 2.在浏览器输入URL，按下回车之后的流程？

* 会通过浏览器缓存、本地缓存、DNS缓存等查询服务器IP地址
* 发送HTTP请求给服务器请求建立连接
* 服务器和主机建立连接后，传输html
* 主机接收html，并根据数据进行渲染
* 可能会断开连接（http1.0/http1.1/http2.0有区别）

![url输入到展示出来的过程](G:\王鹏\面试\https\牛客面经\京东\images\url输入到展示出来的过程.jpg)

## 3.那在这期间，网络层和数据链路层发生了什么？（不知道）

网络层：发送给目标ip服务器请求后，根据IP地址查找下一跳的MAC地址，使用ARP协议使用IP地址转化为MAC地址。

数据链路层：使用OSPF最短路径寻址技术，让数据在路由器之间传递。

TCP传输层，ARP网络层，OSPF数据链路层，HTTP应用层

## 4.说一下Java的内存模型

java内存模型可分为一下几部分：虚拟机栈，本地方法栈，程序计数器，堆，方法区（1.8改为元空间）。

其中虚拟机栈，本地方法栈，程序计数器是线程私有的，堆，方法区是线程共享的。

1.6中方法区是在JVM内存中，1.8之后就放到了直接内存中。

虚拟机栈是存放运行Java方法时的内存模型，虚拟机栈中存放的是一个个的栈帧，每个栈帧包含5部分：局部变量表，操作数栈，指向常量池的引用，方法返回的地址，附加信息。

当运行一个方法的时候，就会将这个方法压入栈中，当运行结束就会出栈。

本地方法栈中是调用native修饰的方法时所使用的栈，也是在运行时会将方法压入栈，运行结束就出栈。

程序计数器是记录当前线程执行到或者将要执行哪个语句的记录器。用来在线程切换时，保存上下文信息。

堆是存储new出来的对象实例的地方，是垃圾回收的主要区域。

方法区是存放类对象的地方，当一个新的类想加载到JVM中，会先加载类对象到方法区，然后在根据类对象在堆中创建具体实例。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等

## 5.说一下栈桢

虚拟机栈中存放的是一个个的栈帧，每个栈帧包含5部分：局部变量表，操作数栈，指向常量池的引用，方法返回的地址。

局部变量表存放的是方法运行时的局部变量，操作数栈也相当于一个栈，是运行具体操作的地方。

指向常量池的引用，顾名思义，方法可能用到类中的常量，通过引用就可以直接找到数据。

方法返回的地址，在方法执行结束之后，会返回调用它的地方，这里存的是调用它的地址。

## 6.你说一下索引吧，从B+树开始说

mysql的索引有三种，B+树，hash，全文索引

B+树是平衡二叉树的一种变形，B+树的非叶子节点不存储数据，只有叶子节点存储数据。B+树叶子节点中的数据是按照顺序存储的。

mysql有两种引擎，这两种引擎都是使用B+树实现的，一种是INNODB，一种是MYISAM。

innodb中B+树的叶子节点是存储数据的地方，叶子节点之间通过指针相连。innodb的主索引是聚簇索引，找到了key就找到了实际的数据，myisam主索引不是聚簇索引，myisam叶子节点存储的是文件的路径，需要通过key在进行查找才可以找到对应的数据。

hash索引，利用hash完成数据的存储，查找效率高，但是无法进行范围查询。在innodb中使用拉链发解决碰撞问题。

全文索引，分为倒排文件索引，详细倒排索引。倒排文件索引格式为关键词，文章ID，详细倒排索引格式为关键词，（关键词所在ID，文档中的位置）。

## 7.为什么用B+树而不用Hash呢？

1.hash不能进行范围查询

2.hash不能进行排序

3.hash在数据量大时，发生hash冲突的概率也很大。

4.hash不持支部分索引。

## 8.Innodb对比其他数据库引擎的优势是什么

1.支持行级锁

2.支持外键

3.支持事务

4.支持MVCC

5.主索引是聚簇索引

## 9.你接触过分布式吗？(没有)
## 10.你是怎么实现Bean的？在Spring里，Bean的生命周期知道吗？

实现BEAN可以通过@bean注解，或者xml进行配置。

bean的生命周期：

* 根据配置文件读取bean的定义信息。
* 利用java 反射创建bean实例
* 如果设计一些属性值，使用set（）方法设置属性值
* 如果实现了*Aware接口，则调用相应的方法
* 如果有和加载bean的spring容器相关的beanpostprocessor对象，调用postprocessorbeforeinitilaztion（）方法
* 如果实现了initialazingbean接口，执行afterpropertitesset（）方法
* 如果配置了init-method属性，执行相应的方法
* 如果有何加载bean的spring容器相关的postbeanprocessor对象，调用postprocessorafterinitilaztion（）方法
* 如果实现了destoryablebean接口，执行destory方法
* 如果配置了destory-method属性，需要执行相应的方法



## 11.那你是怎么实现AOP的？

aop可以在不影响原有功能的条件下，实现横向的扩展功能。比如控制层（Controller）->业务层（Service）->数据层（dao）,那么从这个结构下来的为纵向，它具体的某一层就是我们所说的横向。我们的AOP就是可以作用于这某一个横向模块当中的所有方法。

当我们需要为多个对象引入一个公共行为，比如日志，操作记录等，就需要在每个对象中引用公共行为，这样程序就产生了大量的重复代码，使用AOP可以完美解决这个问题。